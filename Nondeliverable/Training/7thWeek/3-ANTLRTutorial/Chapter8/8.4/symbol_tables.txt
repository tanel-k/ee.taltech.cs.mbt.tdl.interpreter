Language implementers typically call the data structure that holds symbols a symbol table.
The language being implemented dictates a symbol table's structure and complexity.
If a programming language allows the same identifier to mean different things in different context, the symbol table groups symbols into scopes.

A scope is just a set of symbols such as a list of parameters for a function or the list of variables and functions in a global scope.

The symbol table by itself is just a repository of symbol definitions - it doesn't do any checking.
To validate code, we need to check the variable and function references in expressions against the rules we set up earlier.
There are two fundamental operations for symbol valiation: defining symbols and resolving symbols.
Defining a symbol means adding it to a scope.
Resolving a symbol means figuring out which definition the symbol refers to.
In some sense, resolving a symbol means finding the closest matching definition.
The closest scope is the closest enclosing scope.

Scopes form a tree to the root global scope.
The nodes along the path from any scope to the root (global scope) form a stack of scopes.
To find a symbol's definition, we start in the scope surrounding the reference and walk up the scope tree until we find its definition.

Requires source code from chapter 6 of "Language Implementation Patterns".
