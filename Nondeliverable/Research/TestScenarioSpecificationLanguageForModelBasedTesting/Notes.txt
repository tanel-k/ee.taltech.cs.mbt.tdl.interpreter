Abstract
========
Paper defines a high-level test scenario specification language TDL(TP) for specifying complex test scenarios that are needed for model-based testing of mission critical systems.
The syntax and semantics of TDL(TP) operators are defined and the transformation rules that map declarative TDL(TP) expressions to executable test models represented as Uppaal timed automata are specified.

1. Introduction
================
In model-based testing (MBT), the requirements model of the system under test (SUT) describes the expected correct behavior of the system under possible inputs from its environment.
The model, represented in a suitable machine interpretable formalism, can be used to automatically generate the test cases either offline or online, and as the oracle that checks if the SUT behavior conforms to this model.
Offline test generation means that tests are generated before test execution and executed when needed.
In online test generation the model is executed in lock step with the SUT.
The test model communicates with the SUT via controllable inputs and observable outputs of the SUT.

Test description in MBT typically relies on two formal representations, the SUT modeling language and the test purpose specification language.
The requirements to the test purpose specification language for MBT can be summarized as follows:
1. intuitive and user-friendly specification process;
2. expressiveness to capture the features and behaviors under test in a compact and unambiguous form;
3. formal semantics to make the test purpose specifications verifiable and pertinent for automated test generations;
4. decidability to make test generation from test purpose specification algorithmically feasible.

Most test purpose specification languages suffer from some disadvantages, either they have imprecise or informal semantics, lack of standardization, lack of comprehensive tool support, or poor interoperability with other development and testing tools.
ETSI intended to address these shortcomings and developed a new specification language standard by introducing the Test Purpose Language (TPLan) that supports high-level expression of test purposes in prose:
> "Etsi es 202 553: Methods for testing and specification (mts)." TPLan: A notation for expressing Test Purposes
Though TPLan provides notation for standardized specification of test purposes, it leaves a gap between the declarative test purpose and its imperative implementation in test.
Without formal semantics the development by means of test descriptions of different notations and dialects led to overhead and inconsistencies that need to be checked and fixed manually.
As a consequence, ETSI started a new initiative by developing the Test Description Language TDL:
> "Evolving the etsi test description language" (System analysis and modeling, technology-specific aspects of models; Springer)

TDL is intended to bridge the gap between declarative test purposes and imperative test cases by offering a standardized approach for the specification of test descriptions.
The main benefits of ETSI TDL are higher quality tests through better design, easier layout to review by non-testers, better and faster test development, and seamless integration of methodology and tools.

ETSI TDL was driven by industry where it is used primarily (but not exclusively) for functional testing.
Though TDL is one of the most advanced test purpose description languages, it has room for improvements.

The main limitation of TDL is restricted timing semantics.
The Time package in TDL contains concepts for the specification of time operations, time constraints, and timers.
Since time in TDL is global and progresses monotonically in discrete quantities, there is no way of expressing synchronization conditions between local time event of parallel processes and detecting possible Zeno computations that can be analyzed in continuous-time models.
Similarly time-divergence and timelock-freedom cannot be analyzed.

One step further towards automatic test generation was timed games based synthesis of test strategies, implemented in the Uppaal Tiga tool:
"A game-theoretic approach to real-time system testing"
Timed Computation Tree Logic (TCTL), used for specifying test purposes in this approach has high expressive power and formal semantics relevant for expressing quantitative time properties combined with CTL (temporal) operators such as "always", "inevitable", "potentially always", "possible", and "leads-to":
> "Uppaal SMC tutorial"

*Confusion-point follows*
Due to the complexity of model checking, the TCTL syntax in Uppaal is limited with un-nested operators making TCTL expressions "flat" with respect to the temporal operators.
On the other hand, to specify properties of timed reachability the flat TCTL expressions sufficient.
They are not enough to specify complex properties - so-called auxiliary property-recognizing automata ("stopwatch" automata) are needed.

Modifying test model structure by adding property automata is not trivial and may be an error-prone process leading to unintended changes in the semantics of tests.

The aim of this work is to build an extra language layer (Test Scenario Definition Language - TDL(TP)), for test scenario specification that is:
* expressive;
* free from the limitations of flat TCTL;
* interpretable in Uppaal and
* suited for test generation.

In our approach, Uppaal Timed Automata (TA) ("Timed Automata: Semantics Algorithms and Tools", 87-124) serve as a SUT specification language.
Uppaal TA have been chosen because they are designed to express the timed behavior of state transition systems and there exists a set of tools that supports model construction, verification and online model-based testing.

For the test purpose specification language to be concise and still expressive, its specification language must be more abstract than the SUT modeling language and not necessarily self-contained (in the sense that its expressions are interpreted in the context of the SUT model only).
This means that the terms of test purpose specification refer to the SUT model structural elements of interest.
These are called test coverage items (TCIs).
The test purpose specification language TDL(TP) proposed here allows expressing multiple coverage criteria in terms of TCIs, including test scenario constraints such as 'iteration', 'next', 'leads to' and structural coverage criteria such as 'selected states', 'selected transitions', 'transition pairs' and timing constraints (f.ex 'time bounded leads to').

Generating a test model based on the SUT model and TDL(TP) coverage expressions includes two phases.

In the first phase, the TCIs have to be labeled in the SUT model with Boolean variables called "traps".
The traps are needed to make TCIs referable in the TDL(TP) expressions.

*Confusion-point follows - not sure what an RPT is yet*
In case of non-deterministic SUT models the coverage of elementary TCIs is ensured by reactive planning tester (RPT) automata, one automaton for each conjunctive set of TCIs.
(RPT generation: "Online testing of nondeterministic systems with reactive planning tester", 113-150)

In the second phase of generation, a test supervisor model M(SVR) is constructed from the TDL(TP) expression to trigger the RPT automata according to the test scenario so that the temporal and logical coverage constraints stated in the TDL(TP) specification would be satisfied.

*Confusion-point follows*
Since non-deterministic SUT model-based tests are partially controllable, only pseudo-optimal traces can be generated by this method.
Alternatively, in case of deterministic SUT models, the RPT automata generation phase can be discarded since Uppaal generates optimal witness traces from the parallel composition of SUT and tester models.

2. Uppaal timed automata
=========================
Uppaal timed automata (TA) used for modelling SUT is defined as a closed network of extended timed automata that are called processes.
The processes are gathered into a single system by parallel composition known from the process algebra CCS:
> http://theory.stanford.edu/~rvg/process.html
> https://en.wikipedia.org/wiki/Process_calculus
> https://www.cs.vu.nl/~wanf/BOOKS/procalg.pdf

The nodes of the automata are called locations and the edges represent transitions.
The state of an automaton consists of its current location and assignments to all variables, including clocks.

Synchronous communication btwn processes is by hand-shake synchronization links that are called channels.
A channel relates a pair of edges labeled with symbols for input actions (e.g. chA?) and output actions (e.g. chA!).
While synchronous communication between processes is modeled using channels, asynchronous communication between processes is modeled using global variables accessible to all processes.

Formally Uppaal TA are defined as follows:
Let Sig denote a finite alphabet of actions: a, b, c, .... and C a finite set of real-valued variables p, q, r, denoting clocks.
A guard is a conjunctive formula of atomic constraints of the form p ~ n for p in C and ~ in {<=, >=, <, >, =} and n in Z+  U {0}.
We use G(C) to denote the set of clock guards.
A timed automaton A is a tuple <N, l_nil, E, I> where N is a finite set of locations, l_nil from N is the initial location,
E in N x G(C) x Sig x 2^C x N is the set of edges and I : N -> G(C) assigns invariants to locations. Here we restrict to constraints in the form p <= n or p < n, n in Z+ U {0}.
WLG we assume that guards are in conjunctive form iwth conjuncts including besides clock constraints also constraints on integer variables.
Similarly to clock conditions, the props on integer variables k are of the form k ~ n where n is Z+ U {0} and ~ in (see above).
For the formal definition of Uppaal TA semantics:
Behrmann, A Tutorial on Uppaal
Vain, Online testing of nondeterministic systems with reactive planning tester (113-150)

3. TDL(TP) Syntax
==================
Ground terms in TDL(TP) are sets of assignments (TS) to auxiliary variables called traps.
Traps are added to the SUT model for test purpose specification.
* Confusing sentence - means that some TCI is labeled with a var that causes the trap to be updated *
A trap is updated by a Boolean variable assignment (note: update function) that labels a TCI (test coverage item - terms of test purpose spec that refer to structural elements of interest).

In case of Upaal TA, TCIs are edges of the SUT model M(SUT).
The value of a trap is initially set to false.
When the edge of M(SUT) labelled with a trap (!) is visited during test execution, the trap update function is executed and the trap value is updated.

Trap tr is elementary if its update function is unconditional (of shape tr := true).

Generally we assume that trap names are unique, trap update functions non-recursive and the arguments for the latter have definite values whenever an edge labeled with the trap is executed.
Trap tr update condition, in the case of a conditional trap, is a Boolean expression (i.e. update constraint) the arguments of which range over the sets of variables and constants of M(SUT) and over auxiliary constants and variables occurring in the test purpose spec in TDL(TP) (f.ex references to other traps, event counters and time bounds of the clocks in the model).

Although we deal with finite sets of traps and their value domains, we introduce quantifiers for TDL(TP) for notational convenience.
To refer to situations where many traps have to be true or false at once, we group traps to sets called trapsets (TS), and prefix them with trapset quantifiers: A for universal, E for existential.

A(E) means that all traps, and E(TS) means that at least one trap of the set TS needs to be true.

To represent a trapset in Uppaal TA syntax we encode them as one-dimensional trap arrays and refer to individual traps in the array by array index value, f.ex. the i-th trap in TS is referred to as TS[i].

In the following we give the TDL(TP) syntax in BNF:
<Expression>    ::=
                '(' <Expression> ')'
                | 'A'<TrapsetExpression>
                | 'E'<TrapsetExpression>
                | <UnaryOp> <Expression>
                | <Expression> <BinaryOp> <Expression>
                | <Expression> ~> <Expression>
                | <Expression> ~> '[' <RelOp> <NUM> ']' <Expression>
                | '#' <Expression> <RelOp> <NUM>

<TrapsetExpression> ::=
                    '(' <TrapsetExpression> ')'
                    | '!' <ID>
                    | <ID> '\' ID>
                    | <ID> ';' <ID>

<UnaryOp>           ::= 'not'
<BinaryOp>          ::= '&' | 'or' | '=>' | '<=>'
<RelOp>             ::= '<' | '=' | '>' | '<=' | '>='
<ID>                ::= 'TR' <NUM> /* ? bad design - it's very annoying to code with numerical identifiers instead of strings */
<NUM>               ::= ('0'...'9')

4. TDL(TP) Semantics
=====================
/* What does [[..]] mean here? */
To define the semantics of TDL(TP) we assume that we are given:
- an Uppaal TA model M;'
- trapset TS which is possibly a union of member trapsets where the cardinality of each member TS is varying;
- L : TS -> E(M) - a labeling function that maps traps in TS to edges in E(M), where E(M) denotes the set of edges of the model M. We assume the uniqueness of the labeling within a trapset. There is at most one edge labeled with a trap from the given trapset but an edge can be labeled with many traps if each of them is from a different trapset.

4.1 Atomic labeling function
-----------------------------
The atomic labeling function is a non-surjective, injective-only mapping from TS to E(M), i.e each element of TS is mapped to a unique edge in E(M):
L: TS -> E(M), such that for every e in E(M) we have that TS(k)[i] in L(e) && TS(k)[j] in L(e) -> i = j

4.2 Derived labeling operations (trapset operations)
----------------------------------------------------
The formulas with a trapset operation symbol and trapset identifiers as arguments are called TDL(TP) trapset formulas.

Relative complement of trapsets: TS1 \ TS2:
Only those edges labeled with traps of TS1 and not with traps of TS2 are in the relative complement trapset of TS1 \ TS2.

Absolute complement of a trapset (! TS). All edges that are not labeled with traps of TS are in the absolute complement trapset !TS.

Linked pairs of trapsets (TS1 ; TS2): Two trapsets TS1 and TS2 are linked via operator next (;) iff there exists a pair of edges in M which are labeled with traps of TS1 and TS2
respectively and which are connected through a location so that if any traps of TS1 are updated to true on the k-th transition of model M's execution trace sigma, then some trap of TS2 is updated to true in the (k+1)-th transition of that trace.
/* Looks like a boolean op to me; the other two are set operations - why would we mix the two? What does A(TS1 ; TS2) mean then? */
/* Probably selects those traps that can form such pairs? */

4.3 Interpretation of TDL expressions
--------------------------------------
Quantifiers of trapsets: Given the definitions of trapset operations we define the semantics of the bounded quantifiers A and E:
[[A(TS)]] iff for every i in [0, n]: TS[i]
[[E(TS)]] iff for some i in [0, n]: TS[i].

Note that quantification is defined on trapsets only and not on higher level operators. /* What's higher level here? We can make our grammar easier thanks to this I think. */ /* higher level defined under Logic connectives */

Logical connectives: Since recursive nesting of TDL(TP) logic and temporal operators is allowed for higher expressiveness, we define the semantics of higher level operators where argument terms are NOT trapset formulas but derived from them using recursive nesting of logic and temporal operator symbols.
Let SE, SE1 and SE2 denote such argument sub-formulas, then:
[[SE1 & SE2]]iff [[SE1]] and [[SE2]]
[[SE1 or SE2]] iff [[SE1]] or [[SE2]]

SE => (propose ->) SE2 log equiv to not(SE1) or SE2
SE1 <=> SE2 log equiv to (SE1 -> SE2) and (SE2 -> SE1)

Temporal operators
Leads to operator SE1 ~> SE2 in TDL(TP) is inspired by CTL's 'always leads to' operator.
'Leads to' expresses that after reaching a state that satisfies the LHS in the computation, all possible continuations of the computation reach a state in which RHS is satisfied.
[[SE1 ~> SE2]] iff for all sigma and some l, k<=l we have that [[SE1]](sigma(k)) -> [[SE2]](sigma(l))

'Time bounded leads to' means that TS2 must occur after TS1 and the time instance of TS2's occurrence (measured relative to TS2's occurrence satisfies constraint * n where * in {<, =, >, <=, >=} and n in Z+ U {0}:
[[SE1 ~>[* n] SE2]] iff for every sigma, some l, k<=l we have that [[SE1]](sigma(k)) -> [[SE2]](sigma(k))

[[...]]sigma(k) - interpretation of the trapset inside the brackets on the k-th suffix of trace sigma.

Conditional repetition: Let k enumerate the occurrences of [[SE]], then [[#SE * n]] iff [[SE]](1) ~> ... ~> [[SE]](k) and k * n (k is an index variable).

The application of logical negation to non-ground level TDL(TP) terms has the following interpretation:
not(A(TS)) iff some member of TS is false 
not(E(TS)) iff all members of TS are false
not(SE1 and SE2) equivalent to negation of disjunction of negations
not(SE1 or SE2) equivalent to negation of conjunction of negations
not(SE1 -> SE2) (as expected)
not(SE1 <-> SE2) (ditto)

[[not(SE1 ~> SE2)]] iff [[not(SE1)]] or for every l, k<=l: [[SE1]]sigma(k) and not [[SE2]]sigma(l) /* This seems wrong */
not(SE1 ~>[*n] SE2) equivalent to not(SE1 ~> SE2) or for all fi (SE1 ~>[fi] SE2) -> not(fi * n)
not(#TS *n) equivalent to for all fi: (#TS fi) -> (not(fi * n))

5. Mapping TDL(TP) expressions to behavior recognizing automata
================================================================
When mapping TDL(TP) formulae to test supervisor component automata we implement the mappings starting from the ground level terms (TS) and move towards the root term by following the structure of the TDL(TP) formula parse tree.
The terminal nodes of any TDL(TP) formula parse tree are trapset identifiers.
The next layer above the terminal layer constitute trapset operation symbols.
The trapset operation symbols, in turn, are arguments of logical and temporal operators.

Ground level trapsets and trapsets which are the results of trapset operations are mapped to the labeling of SUT model M(SUT).
In the following the mappings are specified for TDL(TP) trapset ops, logical operators and temporal operators in separate subsections.

5.1 Mapping TDL(TP) trapset expressions to SUT model M(SUT) labeling (labeling operations)
-----------------------------------------------------------------------
Mapping M1: Relative complement of trapsets TS1 \ TS2
The TS1\TS2 mapping adds the traps of the trapset TS1\TS2 only to these edges of M(SUT) which are labeled with traps of TS1 and not with traps of TS".
/* It represents a new trapset whose members need to be added to M(SUT) as labels */

Mapping M": Absolute complement of a trapset !TS:
The mapping of !TS to SUT model creates a new trapset whose traps will label all such edges of M(SUT) which are not labeled with traps of TS.

Mapping M3: Linked pairs of trapsets TS1 ; TS2:
The mapping of terms TS1 ; TS2 to labeling is implemented by Algorithm 1:
forall e', e'', i, j, pred(e'') = succ(e') && TS1[i] in L(e')
loop
    if TS2[j] in L(e'')
    then
        Assignments(e') <- Assignments(e') + flag(TS1; TS2) = true
        Assignments(e'') <- Assignments(e'') + TS(TS1;TS2)[j] = (flag(TS1;TS2) ? true : false) /* This doesn't make any sense, just copy the value of flag(TS1;TS2)? */
    fi
    Assignments(e'') <- Assignments(e'') + flag(TS1; TS2) = false
end loop

Note that the labeling concerns not only the edges that are labelled with traps of TS1 and TS2 but also other edges that depart from the same location as the edge with TS2 labeling.
This is necessary for resetting the auxiliary flag variable which indicates the execution of a trapset TS1 labeled edge in the previous step of the computation.

5.2 Mapping TDL(TP) logical operations to recognizing automata
-----------------------------------------------------------------------
The indexing of trapset array elements, universal and existential quantifiers in Uppaal support direct mapping of trapset quantifiers to forall and exists expression of Uppaal TA.
Mapping M4: Universal quantifier
[i] ---> [Ready] -(forall(i: index) TS[i])->[End]

Mapping M5: Existential quantifier
[i] ---> [Ready] -(exists(i:index) TS[i])-> [End]

Negation:
Since logical negation can be pushed to ground level trapset terms via equivalences, the direct mappings of not formulas are not considered in this work.

Mapping M6: Conjunction of sub-formulas:
Let P and Q encode the argument terms SE1 and SE2 of SE1 & SE2 respectively.
          /----P---->[  ]-----Q---->\
[idle]--->[Ready]                   [Committed]--->[End]
          \----Q---->[  ]-----P---->/

Mapping M7: Disjunction of sub-formulas:
          /--------P--------->\
[idle]--->[Ready]             [Committed]--->[End]
          \--------Q--------->/

The implication of TDL(TP) formulas can be defined using disjunction and negation as shown above and their transformation to property automata are implemented via these mappings.
Similarly, equivalence of TDL(TP) formulas can be expressed via conjunction and implication.

5.3 Mapping TDL(TP) temporal operators to recognizing automata:
Mapping M8: Leads to: p~>q:
Mapping the 'leads to' operator to Uppaal TA produces the model fragment depicted below:
[idle]--->[Ready_for_P]----P----->[Ready_for_Q]----Q---->[End]

Mapping M9: Timed leads to p ~>*n q
Mapping 'timed leads to' to an Uppaal TA fragment is depicted low. It presumes a1n additional clock cl which is reset to 0 at the time instant when formula P becomes true. The condition 'cl<=d' sets the upper time bound d to the event when formula Q has to become true after P, i.e. after the clock cl is reset:
                      /<-------(cl > d)--------------------------\
[idle]-------->[Ready_for_P]-----(P; cl=0)---->[  ]-----(Q)---->[Committed]--(cl <= d)--->[End]

                                                  /<-(cl <= d)--\
[idle]-------->[Ready_for_P]-----(P; cl=0)---->[  ]-----(Q)---->[Committed]--(cl > d)--->[End]

The mapping to property automaton depends on the time condition of leads to. cl > d means the second version of the automaton should be used.

Mapping M10: Conditional repetition #SE * n:
The Uppaal TA fragment generated by the mapping includes a counter variable i to enumerate the events when the SE formula P becomes true.
If the loop exit condition (f.ex i >= n) is satisfied then the transition to location End is fired without delay (the middle location is committed).
                       /<--(not ExitCond(i)--\
[idle]---------->[Ready]---(P; i++)--->[Committed]---(ExitCond(i)--->[End]

6. Reduction of the supervisor automata and the labeling of the SUT
====================================================================
TDL(TP) expressions with many nested operators may become large and involve some overhead. Removal of this overhead in the formulas reduces the state space needed for model checking and improves readability of formulae.
Simplifications are formulated in terms of the prase tree of the TDL(TP) formula and standard logical simplifications.
Due to nesting of operations in the TDL(TP) formula, the root operation can be any operator listed in the BNF grammar of TDL(TP) but terminals are always trapsets.

TDL(TP) formulas consist of a static component (a trapset or a trapset expression) and optionally a logical and/or temporal component.
The static component includes all sub-formulas of the parse tree branches from terminals to the lowest temporal expression, all sub-formulas above it are temporal and/or logical formulas (possibly mixed).

Trapset formulas are implemented by labeling operations such as relative and absolute complement.
Only trapset formulas can be universally and existentially quantified.
No nesting of quantifiers is allowed.
Since the validity of root formula can be calculated only using the truth value of the highest trapset expression in the parse tree, all trapsets closer to the ground level trapset along the sub-branch of the parse tree can be removed from the labeling of the SUT model.
The reduction above can be done after labeling the SUT model and applying all trapset operations (labeling operations). /* This is simple enough; we can just label a new instance of the model - old labels wont carry over; darn it: can't do that since some labels are related to the actual model; have to filter somehow */
Basically we don't need the simple labels anymore because the labels derived from operations already encode them implicitly.

Logical simplification follows after the simplification of trapset expressions. Standard logical simplifications are applicable:
p & p equiv p
p & not p equiv false
p & false equiv false
p & true equiv p
p or p equiv p
p or not p equiv true
p or false equiv p
p or true equiv true
p or p equiv p

TDL(TP) temporal operators can also be simplified
TS equiv false if TS is empty set
p ~> false equiv false
false ~> p equiv false
true ~> p equiv p
p ~> true equiv true /* ? */
#p = 1 equiv p
#p * n1 & #p * n2 equiv p * max(n1,n2) if * in {>=, >}
#p * n1 or #p * n2 equiv p * min(n1,n2) if * in {<=, <, =}
#p * n1 & #p * n2 equiv false if * in {=} and n1 != n2
#p * n1 ~> #p * n2 equiv #p * (n1 + n2) if * in {>=, >,=}  /* seems wrong: #p > n1 ~> #p > n2 equiv #p > max(n1, n2) while max(n1, n2) can be < n1 + n2 */
#p * n1 ~> #p * n2 equiv #p * min(n1,n2) if * in {<}
#p * n1 & #p * n2 equiv #p * min(n1,n2) if * in {<}
#p * n1 or #p * n2 equiv #p * max(n1, n2) if * in {<}
p ~>* d1 q & p ~>* d2 q equiv p ~>* min(d1,d2) q if * in {<=, <}
p ~>* d1 q & p ~>* d2 q equiv p ~>* max(d1,d2) q if * in {>}

/* BIG one below */
So at this point we've labeled the results of the trapset expressions, removed simple trap labels.
How exactly do we envision performing this simplification?
This needs to be done *before* we label the model and generate the recognizing automata, correct?
Otherwise we need to delete or modify existing recognizers?

7. Composing the test supervisor model
======================================
The test supervisor model M(SVR) is constructed as a parallel composition of TDL(TP) single property recognizing automata each of which is produced by parsing the TDL(TP) formula and mapping corresponding sub-formulae to the automaton template as defined in Section 5.
To interrelate these sub-formulae automate, two phases have to be completed:
1) Each trap-labeled transition e of M(SUT) (!) (traps which are left after label reduction - in Section 6) has to be split in two edges e' and e'' connected via an auxiliary committed location l(c).
The edge e' will inherit the labeling of e.
e'' will be labeled with an auxiliary BROADCAST channel that signals the trap update to any upper sub-formulae automatons.
Channel naming convention: ch_ + trapset identifier.

2) Each non-trapset-formula automaton (? - figures include trapset-formula automatons!) will be extended with a wrapping construct.
The wrapper has 1 or 2 channel labels (whether it is unary or binaryR), to synchronize its state transition with those of its child expression(s). We call them downwards channels and they are denoted Activate_sub<subopname> and used to trigger the recognizing mode in the first and second sub-formula automata.
Each wrapper also has two additional broadcast channel - they are used to synchronize the state transition of sub-formula automata with their upper operation automaton. We call them upwards channels denoted Activate_<opname> and Done_<opname>.
The root node is exempt from this: it has upwards channels only with the test Stopwatch automaton.
If sub-formulae of a given property automaton are mapped to trapset expressions then the back edge End -> Idle to the initial state is also labeled with trapset reset functions /* NOT explained!??? */.

TDL(TP) sub-formula meta symbols P and Q in the original templates are replaced with channels which signal when the sub-formula interpretation automata reach their local End locations.

8. Encoding test verdict and test diagnostics in the tester model
=================================================================
The test verdict is yielded by the StopWatch automaton either when the automaton reaches its end state within time bond TO or when the timeout event Swatch == TO triggers a transition to the Failed location.
Passed in the StopWatch automaton is reached simultaneously when executing the test purpose formula fi(TP) to its End location.
                                                                        /--[Done_P?]-->[Passed]
["Ready"; Committed initial] ---(Activate_P!;Swatch=0)--->[; Swatch<=TO]
                                                                       \--[Swatch == TO]-->[Failed]
/* Note the invariant Swatch <= TO */

Another extension to the supervisor model is the capability of recording test diagnostic information.
For that each sub-formula of the test purpose spec formula fi(TP) is indexed according to its position in the parse tree of fi(TP).
A diagnostic array D of type Boolean and of size equal to the # of sub-formulae in fi(TP) is defined in the model.
The initial valuation of D sets all its elements to false.
Whenever a model fragment that corresponds to a sub-formula reaches its end state (sub-formula satisfaction state), the element in D that corresponds to that sub-formula is set to true.
It means that if the test passes, all elements of D are updated to true.
Otherwise, in case the test fails, those elements of D remain false which correspond to the sub-formula automata whose conditions were not satisfied or not reached by the test model run.
The updates D[i] := true of the elements of D, where i is the index of the sub-formula automaton M(op)(i) are shown on the edges that enter their End locations. /* Probably these need to be reset as well */

Test model construction steps can now be summarized:
1. test purpose is specified as a TDL(TP) expression fi(TP);
2. trapsets TS1, ... TSn are extracted from fi(TP) and ground-level TCIs labeled with elements of non-intersecting trapsets;
3. parse tree of the TDL(TP) expression fi(TP) is analyzed and each sub-formula operator is mapped using mappings M1 to M10 to automaton template M(op)(i) that corresponds to the sub-formula operation;
4. the labeling o M(SUT) with traps is simplified and M(SUT) linked with sub-formula automata M(op)(i) via a wrapping constuct that provides channels for signaling about reaching sub-formula satsifaction states;
5. finally, diagnostics extension is added to M(op)(i) automata and the root formula automaton is composed with the Stopwatch automaton M(SW) which decides on pass or fail.

