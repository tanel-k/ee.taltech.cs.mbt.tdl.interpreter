\documentclass[12pt,oneside,a4paper,notitlepage]{report}

\usepackage[backend=biber,sorting=none,maxbibnames=99]{biblatex}
\usepackage{setspace}
\usepackage{syntax}
\usepackage{wasysym}
\usepackage{textcomp}
\usepackage{newfloat}
\usepackage{multirow}
\usepackage{listings}

\title{
	Generation of a Parser for the TDL\textsuperscript{TP} Expression Language
}
\author{Tanel Prikk}
\DeclareFloatingEnvironment[
	fileext   = logr,
	listname  = {List of Grammars},
	name      = Grammar,
	placement = htp
]{GrammarWrapper}
\setlength{\grammarindent}{5em}
\setlength{\grammarparsep}{5pt plus 1pt minus 1pt}

\addbibresource{Sources.bib}
\pagenumbering{gobble}
\singlespacing

\newcommand{\texttilde}{\raisebox{0.5ex}{\texttildelow}}

\begin{document}
	\maketitle

	\section*{Background}
	\par Section 3 in \cite{tdlarticle} describes the syntax of the TDL\textsuperscript{TP} expression language in BNF:

	\begin{GrammarWrapper}
		\begin{grammar}
		% https://tex.stackexchange.com/questions/24886/which-package-can-be-used-to-write-bnf-grammars
		% http://texdoc.net/texmf-dist/doc/latex/mdwtools/syntax.pdf
		<Expression>	::=	'(' <Expression> ')'
		\alt 				'A' <TrapsetExpression>
		\alt 				'E' <TrapsetExpression>
		\alt 				<UnaryOp> <Expression>
		\alt 				<Expression> <BinaryOp> <Expression>
		\alt 				<Expression> '\texttilde\textgreater' <Expression>
		\alt 				<Expression> '\texttilde\textgreater' '[' <RelOp> <NUM> ']' <Expression>
		\alt 				'\#' <Expression> <RelOp> <NUM>
		
		<TrapsetExpressions>	::=	'(' <TrapsetExpression> ')'
		\alt						'!' <ID>
		\alt 						<ID> '\textbackslash' <ID>
		\alt						<ID> ';' <ID>
		
		<UnaryOp>	::= 'not'
		
		<BinaryOp>	::= '\&' | 'or' | '=\textgreater' | '\textless=\textgreater'
		
		<RelOp> 	::= '\textless' | '=' | '\textgreater' | '\textless=' | '\textgreater='
		
		<ID> 		::= 'TR' <NUM>
		
		<NUM> 		::= ('0' ... '9')+
		\end{grammar}
		\caption{TDL\textsuperscript{TP} grammar}\label{bnf:original}
	\end{GrammarWrapper}

	\newpage

	As part of the basic functionality of the interpreter, we need to be able to parse an input expression in TDL\textsuperscript{TP} and traverse the resulting concrete syntax tree (parse tree). The first step towards achieving this functionality is the generation of a lexer and a parser for the language. 

	\section*{Requirements Analysis}
	% https://arxiv.org/ftp/arxiv/papers/1409/1409.2378.pdf ?
	% https://nm.wu.ac.at/nm/strembeck/publications/europlop09.pdf ?
	\par The BNF in grammar~\ref{bnf:original} can be adjusted to make it more convenient for the user to specify expressions. We list the adjustments below:
	\begin{itemize}
		\item to reduce ambiguity, logical operators such as implication (\texttt{'=\textgreater'}) and iff (\texttt{'\textless=\textgreater'}) should be differentiated from relational operators over natural numbers which also use the \texttt{'='} token (i.e \texttt{'\textgreater='}, \texttt{'\textless='}) - we achieve this by replacing \texttt{'='} with the equally easy-to-use token \texttt{'-'} in the logical operators: \texttt{'-\textgreater'}, \texttt{'\textless-\textgreater'};
		\item if at some point we wish to have \texttt{'\textless ID\textgreater'} values that can start with either \texttt{'A'} or \texttt{'E'}, it will be visually difficult to identify usage of the universal (\texttt{'A'}) and the existential (\texttt{'E'}) quantifier in an expression - to fix this, we must enforce the use of brackets around the arguments of these quantifiers;
		\item for consistency, logical negation (\texttt{'not'}), conjunction (\texttt{'\&'}), disjunction (\texttt{'or'}), implication (\texttt{'-\textgreater'}) and equivalence (\texttt{'\textless-\textgreater'}) should all be either textual (\texttt{'not'}, \texttt{'and'}, \texttt{'or'}, \texttt{'implies'}, \texttt{'iff'}) or symbolic (\texttt{'\texttilde'}, \texttt{'\&'}, \texttt{'|'}, \texttt{'-\textgreater'}, \texttt{'\textless-\textgreater'}) - there are arguments for both approaches but the conciseness of the symbolic approach is a good enough argument for it to be chosen;
		\item for consistency, the time-bounded leads-to operator \\ (\texttt{'\texttilde\textgreater [\textless RelOp\textgreater \textless NUM\textgreater]'}) and the conditional repetition operator \\ (\texttt{'\#~\textless Expression\textgreater \textless RelOp\textgreater \textless NUM\textgreater'}) should use the same wrapper construct for the integer relation (square brackets);
		\item for multi-token operators (e.g \texttt{'-\textgreater'}, \texttt{'\textless-\textgreater'}, \texttt{'\textless='}, \texttt{'\textgreater='}), we should allow an arbitrary amount of whitespace between component tokens to reduce the number of potential typing errors.
	\end{itemize}

	\newpage

	\par A new grammar can be produced based on grammar~\ref{bnf:original} and the adjustments we specified previously. This grammar is displayed in the listing below. Each distinguishable expression type is also provided with an identifying label in brackets.
		
	\begin{GrammarWrapper}
		\begin{grammar}
			% https://tex.stackexchange.com/questions/24886/which-package-can-be-used-to-write-bnf-grammars
			% http://texdoc.net/texmf-dist/doc/latex/mdwtools/syntax.pdf
			<Expression>	::=	'(' <Expression> ')'
			\alt 				'A' '(' <TrapsetExpression> ')' \textit{(UQTE)}
			\alt 				'E' '(' <TrapsetExpression> ')' \textit{(EQTE)}
			\alt 				<UnaryOp> <Expression> \textit{(NE)}
			\alt 				<Expression> <BinaryOp> <Expression> \textit{(BLE)}
			\alt 				<Expression> '\texttilde' '\textgreater' <Expression> \textit{(LTE)}
			\alt 				<Expression> '\texttilde' '\textgreater' '[' <RelOp> <NUM> ']' <Expression> \textit{(BLTE)}
			\alt 				'\#' <Expression> '[' <RelOp> <NUM> ']' \textit{(CRE)}
	
			<TrapsetExpressions>	::=	'(' <TrapsetExpression> ')'
			\alt						'!' <ID> \textit{(CTE)}
			\alt 						<ID> '\textbackslash' <ID> \textit{(RCTE)}
			\alt						<ID> ';' <ID> \textit{(LPTE)}
	
			<UnaryOp>	::= '\texttilde'
	
			<BinaryOp>	::= '\&' | '|' | '-' '\textgreater' | '\textless' '-' '\textgreater'
	
			<RelOp> 	::= '\textless' | '=' | '\textgreater' | '\textless' '=' | '\textgreater' '='
	
			<ID> 		::= 'TR' <NUM>
	
			<NUM> 		::= ('0' ... '9')+
		\end{grammar}
		\caption{Modified TDL\textsuperscript{TP} grammar}\label{bnf:modified}
	\end{GrammarWrapper}

	\newpage

	\par We describe the labels used in grammar~\ref{bnf:modified} below: % https://en.wikibooks.org/wiki/LaTeX/Tables

	\begin{table}[h]
		\caption{Expression Types}
		\centering
		\makebox[\textwidth]{
			\begin{tabular}{l l l}
				\hline
				Label 	& Expression Type						& Concrete TDL example \\
				\hline
				UQTE	& Universally quantified trapset expr.		& \texttt{A(!TS1)} \\
				EQTE 	& Existentially quantified trapset expr.	& \texttt{E(TS1;TS2)} \\
				NE 		& Negated 									& \texttt{\texttilde A(TS1/TS2)} \\
				BE 		& Binary 									& \texttt{A(!TS1) \& (E(!TS1) | A(TS1/TS2))} \\
				LTE 	& Leads-to 									& \texttt{E(TS2;TS3)\texttilde\textgreater E(TS1;TS2)} \\
				BLTE 	& Time-bounded leads-to						& \texttt{E(TS2;TS3)\texttilde\textgreater [\textgreater 2] E(TS1;TS2)} \\
				CRE 	& Conditional repetition 					& \texttt{\#A(TS1/TS2)[\textgreater 3]} \\
				CTE 	& Absolute trapset complement				& \texttt{!TS} \\
				RCTE 	& Relative trapset complement				& \texttt{TS1/TS2} \\
				LPTE 	& Linked trapset pair 						& \texttt{TS1;TS2} \\
			\end{tabular}
		}
		\label{tbl:expr-types}
	\end{table}

	\bigskip

	\par The expression types listed in table~\ref{tbl:expr-types} will be used in upcoming sections when describing the implementation of these requirements.

	\bigskip
	\par Note that grammar~\ref{bnf:modified} contains several operators for which we should define precedence rules. These rules are listed below:

	\begin{table}[h]
		\caption{Operator precedence}
		\makebox[\textwidth]{
			\begin{tabular}{l l l l}
				\hline
				Type & Argument domain & Operator & Precedence \\
				\hline
				\multirow{3}{*}{Trapset expression} & \multirow{3}{*}{Trapset symbols}
				  & Absolute complement (\texttt{!}) & 0 \\
				& & Relative complement (\texttt{\textbackslash}) & 1 \\
				& & Linked pair 		(\texttt{;}) & 2 \\
				\hline
				\multirow{2}{*}{Trapset quantifier} & \multirow{2}{*}{Trapset expressions}
				  & Existential quantification (\texttt{E}) & 0 \\
				& & Universal quantification   (\texttt{A}) & 0 \\
				\hline
				\multirow{8}{*}{Logical} & \multirow{8}{*}{Trapset quantifiers}
				  & Negation (\texttt{\texttilde}) & 0 \\
				& & Conjunction (\texttt{\&}) & 1 \\
				& & Disjunction (\texttt{|}) & 2 \\
				& & Implication (\texttt{-\textgreater}) & 3 \\
				& & Equivalence (\texttt{\textless-\textgreater}) & 4 \\
				& & Leads to (\texttt{\texttilde\textgreater}) & 5 \\
				& & Time-bounded leads to (\texttt{\texttilde\textgreater [IntegerRelation]}) & 5 \\
				& & Conditional repetition (\texttt{\# ... [IntegerRelation]}) & 6 \\
			\end{tabular}
		}
		\label{tbl:oper-prec}
	\end{table}

	\newpage

	\subsection*{Requirements Summary}
	\par The TDL\textsuperscript{TP} parser needs to satisfy these primary requirements:
	\begin{itemize}
		\item able to parse a valid expression from grammar~\ref{bnf:modified} and report basic errors for invalid expressions;
		\item adheres to the precedence rules defined in table~\ref{tbl:oper-prec};
		\item provides facilities for the construction of a concrete syntax tree (parse tree). 
	\end{itemize}

	\section*{Implementation}
	\par The following subsections present information on the implementation of the TDL\textsuperscript{TP} parser.

	\subsection*{Technology}
	\par Because we are essentially implementing a proof-of-concept, our main criteria for choosing the appropriate technology are:
	\begin{itemize}
		\item ease-of-use (readability, gradual learning curve);
		\item support for multiple target platforms;
		\item support for parse tree generation.
	\end{itemize}.

	\par In order to save time, it makes sense to use an existing toolkit which satisfies the above-mentioned criteria.

	\bigskip

	\par ANTLR (ANother Tool for Language Recognition, \cite{antlrsite}) is our preferred parser generation tool. Given a grammar, it will generate a (top-down) parser which is capable of building parse trees. We chose ANTLR (version 4) because it supports the following features:
	\begin{itemize}
		\item multiple target languages (including \texttt{Java}, \texttt{Python});
		\item availability of testing and debugging utilities (e.g AST graph generation, lexer debugging);
		\item direct left recursion \cite{antlrrecursion};
		\item generation of parsers whose parsing strategy (\textit{ALL(*)}) tends to exhibit linear time complexity behavior in practice \cite{antlrcomplex}.
	\end{itemize}

	Terence Parr, the author of ANTLR 4, provides a comprehensive ANTLR 4 tutorial in \cite{antlrtutorial}.

	\subsection*{Technical Details}
	\par This section presents implementation details related to using ANTLR 4 to generate a parser for TDL\textsuperscript{TP}.

	\subsubsection*{ANTLR 4 grammar}
	\par ANTLR has its own grammar definition language (described in \cite{antlrtutorial}). The result of converting grammar~\ref{bnf:modified} to an ANTLR  grammar is displayed in the listing below:
	
	\begin{lstlisting}[
		basicstyle=\small,
		caption={ANTLR 4 grammar for TDL\textsuperscript{TP}},label={lst:antlr-gram}
	]
grammar TDLExpressionLanguage;

// Root production:
expression
: LEFT_PAREN expression RIGHT_PAREN  # GroupedExpression
| LOP_NEGATION expression  # NegatedExpression
| expression LOP_CONJUNCTION expression  # ConjunctiveExpression
| expression LOP_DISJUNCTION expression  # DisjunctiveExpression
| expression LOP_IMPLICATION expression  # ImplicativeExpression
| expression LOP_EQUIVALENCE expression  # EquivalenceExpression
| expression LOP_LEADS_TO expression  # LeadsToExpression
| expression LOP_LEADS_TO
	LEFT_BRACKET boundOverNaturals RIGHT_BRACKET expression 
	# TimeBoundedLeadsToExpression
| LOP_REPETITION_COUNT expression
	LEFT_BRACKET boundOverNaturals RIGHT_BRACKET 
	# ConditionalRepetitionExpression
| quantifiedTrapsetExpression  # GroundTermExpression
;

// Ground term for expression (quantified trapset expression):
quantifiedTrapsetExpression
: LOP_UNIVERSAL_QUANTIFIER
	LEFT_PAREN trapsetExpression RIGHT_PAREN
	# UniversalTrapsetExpression
| LOP_EXISTENTIAL_QUANTIFIER
	LEFT_PAREN trapsetExpression RIGHT_PAREN
	# ExistentialTrapsetExpression
;

// Trapset expressions:
trapsetExpression
: LEFT_PAREN trapsetExpression RIGHT_PAREN
	# GroupedTrapsetExpression
| TOP_ABSOLUTE_COMPLEMENT trapsetExpression
	# AbsoluteTrapsetComplementExpression
| trapsetExpression TOP_RELATIVE_COMPLEMENT trapsetExpression
	# RelativeTrapsetComplementExpression
| trapsetExpression TOP_LINKED_PAIR trapsetExpression
	# LinkedTrapsetPairExpression
| TRAPSET_ID
	# TrapsetIdentifierExpression
;

// Partial relation over natural numbers:
boundOverNaturals : REL_LESS_THAN NATURAL_NUMBER  # LessThanBound
| REL_GREATER_THAN NATURAL_NUMBER  # GreaterThanBound
| REL_LESS_THAN_OR_EQ NATURAL_NUMBER  # LessThanOrEqBound
| REL_GREATER_THAN_OR_EQ NATURAL_NUMBER  # GreaterThanOrEqBound
| REL_EQUAL NATURAL_NUMBER  # EqualityBound
;

// Tokens:
// Grouping tokens:
LEFT_BRACKET    : '[' ;
RIGHT_BRACKET   : ']' ;
LEFT_PAREN      : '(' ;
RIGHT_PAREN     : ')' ;

// Logical operators:
LOP_UNIVERSAL_QUANTIFIER    : [Aa] ;
LOP_EXISTENTIAL_QUANTIFIER  : [Ee] ;
LOP_NEGATION                : '~' ;
LOP_CONJUNCTION             : '&' ;
LOP_DISJUNCTION             : '|' ;
LOP_IMPLICATION             : '-' BLANK* '>' ;
LOP_EQUIVALENCE             : '<' BLANK* '-' BLANK* '>' ;
LOP_LEADS_TO                : '~' BLANK* '>' ;
LOP_REPETITION_COUNT        : '#' ;

// Trapset operators:
TOP_ABSOLUTE_COMPLEMENT : '!' ;
TOP_RELATIVE_COMPLEMENT : '\\' ;
TOP_LINKED_PAIR         : ';' ;

// Relations over natural numbers:
REL_LESS_THAN_OR_EQ     : '<' BLANK* '=' ;
REL_GREATER_THAN_OR_EQ  : '>' BLANK* '=' ;
REL_LESS_THAN           : '<' ;
REL_GREATER_THAN        : '>' ;
REL_EQUAL               : '=' ;

// Other:
TRAPSET_ID      : TRAPSET_PREFIX NUMERIC_ID? ;
NATURAL_NUMBER  : ZERO
| NONZERO_DIGIT ANY_DIGIT*
;
NUMERIC_ID      : ANY_DIGIT+ ;

// Fragments (only meant to be used in token productions):
fragment TRAPSET_PREFIX : [Tt][Rr] ;
fragment ZERO           : [0] ;
fragment ANY_DIGIT      : [0-9] ;
fragment NONZERO_DIGIT  : [1-9] ;
fragment BLANK          : [ \t\r\n] ;

// Meta rules:
// Skip whitespace:
WS : BLANK+ -> skip ;
	\end{lstlisting}

	\subsubsection*{Generated Parser Classes}
	\par When the grammar definition in listing~\ref{lst:antlr-gram} is processed by ANTLR, it will generate the following Java classes:
	\begin{itemize}
		\item \texttt{TDLExpressionLanguageParser};
		\item \texttt{TDLExpressionLanguageLexer};
		\item \texttt{TDLExpressionLanguageBaseListener};
		\item \texttt{TDLExpressionLanguageBaseVisitor}.
	\end{itemize}

	\par The final sections in this document are devoted to descriptions of the classes listed above.

	\subsubsection*{\texttt{TDLExpressionLanguageParser}}
	\par 

	\subsubsection*{\texttt{TDLExpressionLanguageLexer}}
	\par 

	\subsubsection*{\texttt{TDLExpressionLanguageBaseListener}}
	\par 

	\subsubsection*{\texttt{TDLExpressionLanguageBaseVisitor}}
	\par 


	\printbibliography[
		title=Sources
	]

\end{document}
