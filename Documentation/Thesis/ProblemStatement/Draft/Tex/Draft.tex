\documentclass[12pt,oneside,a4paper,draft,notitlepage]{article}
\usepackage[backend=biber,sorting=none]{biblatex}
\usepackage{setspace}

\title{
	Implementation and Validation of an Interpreter
	for the Test Scenario Specification Language TDL\textsuperscript{TP}\\
}
\author{
	Student: Tanel Prikk\\
	\texttt{tanel.prikk@taltech.ee}
	\and
	Instructor: JÃ¼ri Vain\\
	\texttt{juri.vain@taltech.ee}
}
\date{March 2019}

\addbibresource{Sources.bib}
\pagenumbering{gobble}
\singlespacing

\begin{document}
	\maketitle
	\section*{Problem Statement}
	\subsection*{Background}
	\par In model-based testing (MBT), behavioral requirements for a system are represented as a models. Such models can be used to generate abstract tests when instrumented with test selection criteria (test purposes) \cite{etsimbt}. This process is called test description.

	\bigskip

	\par Test description requires the use of a system modeling language and a test purpose specification language. The choice of language depends on the nature of the system. For real-time systems, an important consideration is whether the test purpose specification language allows for easy expression of constraints on quantitative time properties.

	\bigskip

	\par Timed Automata (TA) is a widely known formalism for the specification of real-time systems. Our approach assumes the use of \textsc{Uppaal} Timed Automata (UTA) \cite{uppaaltoolkit} as a system under test (SUT) modeling language.

	\bigskip

	\par The query language provided by the \textsc{Uppaal} toolkit is based on timed computation tree logic (TCTL). It can be used for test purpose specification for UTA models. However, while the language has high expressive power, it is limited by the unavailability of nested temporal operators. This means more complex properties require the user to modify the test model with auxiliary property recognizing automata - an error-prone process.

	\bigskip

	\par \cite{missing} describes the syntax and semantics of a supplementary language layer, the Test Scenario Definition Language TDL\textsuperscript{TP}, which is expressive, supports nested temporal operators, and is suited for test generation based on UTA models.

	\bigskip

	\par The objective of this work is to develop an interpreter for the TDL\textsuperscript{TP} language. This interpreter will find use in a prototype environment for model-based testing of cyber-physical systems.

	\subsection*{Expected Results}
	\par The interpreter will accept as input:
	\begin{itemize}
		\item a UTA system model M\textsuperscript{SUT} (in XML); as well as
		\item an expression $\phi^{TP}$ in the TDL\textsuperscript{TP} language.
	\end{itemize}

	\par Based on the provided inputs, the interpreter produces as output a UTA test model in XML format. This test model must implement the test specification represented by $\phi^{TP}$ and must be compatible with the \textsc{Uppaal} toolkit.

	\bigskip

	\par The synthesis of a test model M based on M\textsuperscript{SUT} and $\phi^{TP}$ shall include the following:
	\begin{itemize}
		\item the simplification of the TDL\textsuperscript{TP} expression based on the system model and proven simplification rules for the language;
		\item the creation of a version of the original system model M\textsuperscript{SUT} modified with flag structures based on the simplified TDL\textsuperscript{TP} expression (M\textsuperscript{T});
		\item the creation of an expression model derived from the sub-formulas in the TDL\textsuperscript{TP} expression (M\textsuperscript{E});
		\item the creation of a stop-watch model for encoding test verdict information (M\textsuperscript{SW}); and
		\item the parallel composition of the above-mentioned three models, \\
		$M^{T} \vert M^{E} \vert M^{SW}$ in order to produce the final test model.
	\end{itemize}

	\par The resulting test model can be used in the \textsc{Uppaal} tool to validate the original model based on the test specification. Additionally, it will include diagnostic facilities derived from the parse tree of $\phi^{TP}$, which the user will find useful when analyzing failure cases for the system.

	\subsection*{Validation}
	\par The interpreter is a prototype so we will not impose any restrictive efficiency requirements. However, it must be ensured that the test models generated by the interpreter are functionally correct.

	\bigskip

	\par In order to validate whether the interpreter produces functionally correct models, we plan to present TCTL constraints equivalent to TDL\textsuperscript{TP} expressions in Uppaal's query language. By comparing the test sequences generated by these we can check the functional correctness of the TDL\textsuperscript{TP} interpreter.

	\subsection*{Methodology}
	\par When implementing the interpreter, we shall take a bottom-up approach. In basic terms, this means we will develop input/output serialization components (such as the TDL\textsuperscript{TP} syntax parser and the UTA model serialization component) prior to moving on to the higher level components which implement the logic for the interpreter.

	\bigskip

	\par For the TDL\textsuperscript{TP} syntax parser, we will decide on a suitable Java-based parser generator which produces artifacts that we can easily map to an implementation-independent object model of our own using an adapter. We will take this approach to save time on building a custom parser while leaving the option to simply swap out the existing parser without affecting the top-level artifacts.

	\bigskip

	\par As for the model serialization component, we will either leverage the existing \texttt{libutap} parser library \cite{libutapsite} (developed for \textsc{Uppaal} and provided under the LGPL license) or create our own parser depending on which approach affords the greatest amount of freedom without sacrificing platform-independence.

	\bigskip

	\par Additional research and analysis will be required in order to determine a suitable internal data structure which will facilitate the simplification of TDL\textsuperscript{TP} expressions based on a set of reduction rules.

	\bigskip

	\printbibliography[
		title=Sources
	]

\end{document}

