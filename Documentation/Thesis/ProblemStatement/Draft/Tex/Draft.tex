\documentclass[12pt,oneside,a4paper,notitlepage]{article}
\usepackage[backend=biber,sorting=none,maxbibnames=99]{biblatex}
\usepackage{setspace}

\title{
	Implementation of an Interpreter
	for the Test Scenario Specification Language TDL\textsuperscript{TP}\\
}
\author{
	Student: Tanel Prikk\\
	\texttt{tanel.prikk@taltech.ee}
	\and
	Supervisor: JÃ¼ri Vain\\
	\texttt{juri.vain@taltech.ee}
}
\date{March 2019}

\addbibresource{Sources.bib}
\pagenumbering{gobble}
\singlespacing

\begin{document}
	\maketitle

	\section*{Problem Statement}
	\subsection*{Background}
	\par In model-based testing (MBT), behavioral requirements of a system are captured in a model of the system. When instrumented with test selection criteria (test purposes),  system models can be used to generate abstract tests \cite{etsimbt}. This process is called test description.

	\bigskip

	\par Test description requires the use of a system modeling language and a test purpose specification language. The choice of language depends on the nature of the system. For real-time systems, an important consideration is whether the test purpose specification language allows for easy expression of constraints on quantitative time properties.

	\bigskip

	\par Timed Automata (TA) (described in \cite{mcprinciples}) is a widely known formalism for the specification of real-time systems. Our approach assumes the use of \textsc{Uppaal} Timed Automata (UTA) \cite{uppaaltoolkit} as a system under test (SUT) modeling language.

	\bigskip

	\par The query language available in the \textsc{Uppaal} toolkit is based on timed computation tree logic (TCTL). It can be used for test purpose specification for UTA models. However, while the language has high expressive power, it is limited by the unavailability of nested temporal operators. This means more complex properties require the user to modify the test model with auxiliary property recognizing automata - an error-prone process.

	\bigskip

	\par The theory outlined in \cite{tdlarticle} describes the syntax and semantics of a supplementary language layer, the Test Scenario Definition Language (TDL\textsuperscript{TP}), which is expressive, supports nested temporal operators, and is suited for test generation based on UTA models.

	\bigskip

	\par The objective of this work is to develop an interpreter for the TDL\textsuperscript{TP} language. This interpreter will find use in a prototype environment for model-based testing of cyber-physical systems.

	\subsection*{Expected Results}
	\par The interpreter will accept as input:
	\begin{itemize}
		\item a UTA system model M\textsuperscript{SUT} (in XML); as well as
		\item an expression $\phi^{TP}$ in the TDL\textsuperscript{TP} language.
	\end{itemize}

	\par Based on the provided inputs, the interpreter produces as output a UTA test model in XML format. This test model must implement the test specification represented by $\phi^{TP}$ and must be compatible with the \textsc{Uppaal} toolkit.

	\bigskip

	\par The synthesis of a test model based on M\textsuperscript{SUT} and $\phi^{TP}$ shall include the following:
	\begin{itemize}
		\item the simplification of $\phi^{TP}$ based on M\textsuperscript{SUT} and proven simplification rules for the language;
		\item the creation of a version of M\textsuperscript{SUT} modified with flag structures based on $\phi^{TP}$  (M\textsuperscript{T});
		\item the creation of an expression model derived from the sub-formulas in $\phi^{TP}$ (M\textsuperscript{E});
		\item the creation of a stop-watch model for encoding test verdict information (M\textsuperscript{SW}); and
		\item the parallel composition of the above-mentioned three models \\
		($M^{T} \vert M^{E} \vert M^{SW}$) in order to produce the final test model.
	\end{itemize}

	\par The resulting test model can be executed in the \textsc{Uppaal} tool. Additionally, the model will include diagnostic facilities derived from the parse tree of $\phi^{TP}$, which the user will find useful when analyzing failure cases for the system.

	\subsection*{Validation}
	\par The interpreter is a prototype (more precisely, a proof-of-concept for \cite{tdlarticle}), so we will not impose any restrictive efficiency requirements. However, it should be ensured that the test models generated by the interpreter are functionally correct.

	\bigskip

	\par To this end, we will first cover core interpreter functionality with automated functional tests. The latter will validate whether the interpreter operates according to the requirements laid out in \cite{tdlarticle}. While sufficient functional test coverage is relatively easy to achieve, confirming whether \textit{models} produced by the interpreter are functionally correct is not trivial. We will limit the scope of this work by will simply confirming the correctness of test models generated from a handful of example systems.

	\subsection*{Methodology}
	\par When implementing the interpreter, we shall take a bottom-up approach. In basic terms, this means we will develop input/output serialization utilities (such as the TDL\textsuperscript{TP} syntax parser and the UTA model serialization component) prior to moving on to the higher level components which implement interpreter logic.

	\bigskip

	\par For the TDL\textsuperscript{TP} syntax parser, we will choose a suitable parser generator which produces artifacts that we can easily map to an implementation-independent object model of our own using an adapter. We will take this approach to save time on building a custom parser while leaving the option to simply swap out the existing parser without affecting the top-level artifacts.

	\bigskip

	\par As for the \textsc{Uppaal} model serializer, we will either adapt the existing (yet unfortunately outdated) \texttt{libutap} parser library \cite{libutapsite} (provided under the LGPL license) or create our own parser depending on analysis of the merits of either approach.

	\bigskip

	\par Additional research and analysis will be required in order to determine a suitable internal data structure which will facilitate the simplification of TDL\textsuperscript{TP} expressions based on a set of reduction rules.

	\bigskip

	\printbibliography[
		title=Sources
	]

\end{document}

