### Introduction

Uppaal is a tool suite for symbolic simulation and automatic verification of real-time systems modeled as networks of timed automata, extended with data variables.
The two main design criteria for Uppaal have been *efficiency* and *easy of usage*.

The Uppaal model has been extended with committed locations to model  atomic broadcasting. This notion is further utilized in reducing space-consumption as information about states involving committed locations does not need to be recorded. Also, interleaving behavior of a system is prevented in states involving committed locations.

The current version of Uppaal is implemented in C++. The features and tools of Uppaal include:

* A graphical interface based on Autograph allowing graphical specification of systems;
* A compiler transforming graphical specification into textual format;
* Analysis of certain types of hybrid automata by compilation into ordinary timed automata with data variables. In particular Uppaal allows automata with varying and drifting time-speed of clocks;
* A simulator which provides a graphical visualization and recording of possible dynamic behaviors of system description, i.e. sequences of symbolic states of the system;
* A model-checker for automatic verification of safety and bounded-liveness properties by reachability analysis;
* Generation of diagnostic traces for verification of a particular real-time system.

In this document, we present the semantic model implemented in Uppaal and its various tools such as the model-checker and the simulator.

### Overview of Uppaal

Uppaal consists of a suite of tools for verifying safety properties of real-time systems. In this section we briefly describe the main features of Uppaal.

#### Graphical Description of Networks of Timed Automata

It is possible to draw networks of timed automata using Autograph, given that certain syntactical rules are followed.

#### Textual Description of Networks of Timed Automata

In addition, Uppaal allows networks of timed automata to be described using a textual format (called .ta) providing a basic programming language for timed automata. In certain cases we found this textual format more convenient and faster to work with than the graphical interface.

#### Linear Hybrid Systems

Under certain conditions, the model of timed automata may be generalized to allow clocks with rates varying between a lower and an upper bound, and to allow clock rates to change between different control-nodes (vertices). This extension of timed automata is useful for modeling of hybrid systems where the behavior of the system can be described or approximated using lower and upper bounds on their rates. Using abstraction techniques, this class of linear hybrid systems can be transformed into timed automata and thus be verified using the techniques available for timed automat, implemented in Uppaal. Uppaal allows linear hybrid automata where the speed of clocks is given by an interval.

#### Syntactical Checks

Given a textual description of a timed automaton in the .ta-format the program `checkta` performs a number of syntactical checks. In particular the use of clocks, auxiliary integer variables and channels must be in accordance with their declaration, e.e. attempted synchronization on an undeclared channel will be captured by `checkta`.

#### Model-Checking

In its current iteration, Uppaal is able to check for reachability properties, in particular whether certain combinations of control/nodes and constraints on clocks and integer variables are reachable from an initial configuration.

Bounded liveness properties can be obtained by reasoning about the system in the context of testing automata. Model-checking is performed by `verifyta` which takes as input a network of timed automata in the .ta-format and a formula. `verifyta` can also be used interactively.

#### Simulation

The simulator allows the user to examine in an interactive and graphical fashion the dynamic behavior of a system. In contrast to the model-checker which explores the whole reachable state-space of a system - examining all the behavior of the system, the simulator explores only a particular execution trace, i.e. a sequence of states of the system. This will in the early stages of a design provide an inexpensive means of fault detection. In comparison the model-checker is obviously more expensive as it amounts to an exhaustive simulation covering the behavior of the system.

Another useful application of the simulator is to visualize a diagnostic trace generated by the model-checker; thus the user can in an interactive and graphical fashion examine the execution trace that may result in a system error.

### The Uppaal Model

In this section, we present the syntax and semantics of the model used and implemented in Uppaal to model real-time systems. Emphasis will be put on the precise semantics of the model. For convenience, we shall use a slightly different syntax compared to Uppaal's user interface.

We assume that a typical real-time system is a network of non-deterministic sequential processes communicating with each other over channels. In Uppaal, we use finite-state automata extended with clock and data variables to describe processes and networks of such automata to describe real-time systems.

#### Syntax

The theory of timed automata was developed as an extension of classical finite-state automata with clock variables. To have a more expressive model and to ease the modeling task, we further extend timed automata with more general types of data variables such as Boolean and integer variables. Our final goal is to develop a modeling (or design) language which is as close as possible to a high-level real-time programming language with various data types. Clearly this will create problems for decidability. However, we can always require that the value domains of the data variables be finite in order to guarantee termination of a verification procedure. The current implementation of Uppaal allows integer variables in addition to clock variables.

In a finite-state automaton,  a transition takes the form $l \xrightarrow{\alpha} l'​$ meaning that the process modeled by the automaton will perform an ${\alpha}​$-transition in state $l​$ and reach state $l'​$ in doing so. Note that there is no condition on the transition.

Untimed transitions are extended to a timed version: $l \xrightarrow{g, \alpha, \phi} l'​$ where $g​$ is a simple linear constraint over clock variables and $\phi​$ is a set of clocks to be reset to $0​$. Intuitively, $l \xrightarrow{g, \alpha, \phi} l'​$ means that a process in control node $l​$ may perform an ${\alpha}​$-transition instantaneously when $g​$ is true of the current clock values and then reach control node $l'​$ with the clocks in ${\phi}​$ being reset. The constraint $g​$ is called a *guard*. In Uppaal, we allow a more general form of guard that can also be a constraint over data variables, and extend the reset-operation on clocks in timed automata to data variables.

Now assume a finite set of clock variables $C$ ranged over by $x, y, z$ etc and a finite set of data variables $V$ ranged over by $i, j, k$ etc.

##### Guards over Clock and Data Variables

We use $G(C, V)​$ to stand for the set of formulas ranged over by $g​$, generated by the following syntax: $g ::= a  \vert g \land g​$, where $a​$ is either a timing constraint over $C​$ or a data constraint over $V​$. A timing constraint is of the form $x \sim n​$ or $x - x' \sim n​$ where $n​$ is a natural number and $\sim \in \{\lt, \le, =, \gt, \ge\}​$; a data constraint is of the same form i.e. $i \sim i​$ or $i - i' \sim i​$ but $i​$ may be an integer.

We shall call $G(C, V)$ *guards*. Note that a guard can be divided into two parts: a conjunction of constraints $g_c$'s over clock variables and a conjunction of constraints $g_v$'s over data variables. We shall use $tt$ to stand for a guard like $x \ge 0$ which is always $true$, for a clock variable $x$ as clocks can have only non-negative values. In Uppaal's representation of automata, the guard $tt$ is often omitted.

##### Reset-Operations

To manipulate clock and data variables, we use reset-set in the form: $\bar{w} := \bar{e}$ which is a set of assignment-operations of the form $w := e$ where $w$ is a clock or data variable and $e$ is an expression. We use $R$ to denote the set of all possible reset-operations.

The current version of Uppaal distinguishes clock variables and data variables: a reset-operation on a clock variable should be of the form $x := n$ where $n$ is a natural number and a reset-operation on an integer variable should be of the form $i := c * i + c'$ where $c, c'$ are integer constants. Note that $c, c'$ can be zero or negative.

##### Channel, Urgent Channel and Synchronization

We assume that processes synchronize with each other via channels. We further assume that each communication synchronizes two processes (handshake).

Let $A$ be a set of channel names and out of $A$, there is a subset $U$ of urgent channels on which processes should synchronize as soon as possible. We use $Act = \{\alpha? \vert \alpha \in A\} \cup \{\alpha! \vert \alpha \in A\}$ to denote the set of actions that processes can perform to synchronize with each other. We use $name(a)$ to denote the channel name of $a$, defined by $name(\alpha?) = name(\alpha!) = \alpha$.

##### Committed Locations

We use an example to introduce the notion of committed locations. Firstly note that communication between processes is one-to-one. However, broadcasting communication can be implemented in such systems by repeatedly sending the same message to all the receivers. Now, consider the following scenario: A sender $S$ is to broadcast a message $m$ to two receivers $R_1$ and $R_2$. As this requires synchronization between $three$ processes this can not directly be expressed in Uppaal where synchronization (as in [CCS](https://en.wikipedia.org/wiki/Calculus_of_communicating_systems)), is between two processes based on the complementarity of actions. However, as an initial attempt we may model the broadcast as a sequence of two two-process synchronizations, where $S$ synchronizes with $R_1$ on $m_1$ and then with $R_2$ on $m_2$. However, this is not an accurate model as the intended atomicity of the broadcast is not preserved (i.e. other processes may interfere during the 'broadcast' sequence). To ensure atomicity, we mark the intermediate location $S_1$ of the sender $S$ as a so-called *committed* location (indicated by the $c:$-prefix). The atomicity of the action sequence $m_1!m_2!$ is now achieved by insisting that a committed location must be left immediately. This behavior is quite similar to what has been called "urgent transitions", which insists that the next transition taken must be an action (and not a delay).

##### Automata with Constraints and Committed Locations

Now we present an extended version of timed automata with data variables, reset-operations, urgent channels and committed locations.

**Definition 1** An automaton $A​$ over actions $Act​$ with urgent actions $U \subseteq Act​$, clock variables $C​$ and data variables $V​$ is a tuple $\lang L, l_0, E, C, I \rang​$ where:

* $R$ is the set of all possible reset-operations;
* $L$ is a finite set of locations (control-locations);
* $L_C \subseteq L​$ is the set of committed locations;
* $l_0​$ is the initial location;
* $E \subseteq L \times G(C, V) \times Act \times 2^R \times L$ is the set of edges between locations;
* $I​$ is a function which for each location $l​$ assigns a clock constraint $I(l)​$ in the form $x \underline{\prec} n​$ where $\underline{\prec} \in \{ \lt, \le\}​$ ($I(l)​$ is called the invariant of $l​$).

In modeling urgency, we require that the guard of an edge with an urgent action should always be $tt$ (always true), i.e. if $name(a) \in U$ and $\lang l, g, a, r, l'\rang \in E$ then $g \equiv tt$.

In the case, $\lang l, g, a, r, l' \rang \in E​$ we shall write, $l \xrightarrow{g, a, r} l'​$ which represents a transition from the location $l​$ to the location $l'​$ with guard $g​$ (also called the enabling condition of the edge), action $a​$ to be performed and a set of reset -operations $r​$ to update the variables.

For convenience, we shall, in the following, use a predicate $C$ to distinguish committed locations from others; thus $C(l)$ is true if $l \in L_c$.

##### Concurrency and Synchronization

To model networks of processes, we introduce a [CCS](https://en.wikipedia.org/wiki/Calculus_of_communicating_systems)-like parallel composition operator for automata. Assume that $A_1, ..., A_n$ are automata with clocks and data variables. We use $\bar{A}$ to denote their parallel composition. The intuitive meaning of $\bar{A}$ is similar to the [CCS](https://en.wikipedia.org/wiki/Calculus_of_communicating_systems) parallel composition of $A_1, ..., A_n$ with *all* actions being restricted that is,
$$
(A_1 \vert \ldots \vert A_n)\setminus A
$$
Thus only synchronization between the components $A_i​$ is possible. We shall call $\bar{A}​$ a network automata. We simply view $\bar{A}​$ as a vector and use $A_i​$to denote its $i​$th component.

#### Semantics

Informally, a process modeled by an automaton starts at location $l_0$ with all its clocks and data variables initialized to $0$. The values of the clocks increase synchronously with time at location $l$. At any time, the process can change location by following an edge $l \xrightarrow{g, a, r} l'$ provided the current values of the clocks satisfy the enabling condition $g$. With this transition, the variables are updated by $r$.

##### Variable Assignment

A variable assignment is a mapping which maps clock variables $C​$ to the non-negative reals and data variables $V​$ to integers. For a variable assignment $v​$ and a delay $d​$, $v \oplus d​$ denotes the variable assignment such that $(v \oplus d)(x) = v(x) + d​$ for any clock variable $x​$ and $(v \oplus d)(i) = v(i)​$ for any integer variable $i​$. This definition of $\oplus​$ reflects that all clocks operate with the same speed and that data variables are time-insensitive. For a reset-operation $r​$ (a set of assignment-operations), we use $r(v)​$ to denote the variable assignment $v'​$ with $v'(w) = val(e, v)​$ whenever $(w := e) \in r​$ and $v'(w') = v(w')​$ otherwise, where $val(e, v)​$ denotes the value of $e​$ in $v​$ (*basically non-affected variables are not affected*). Given a guard $g \in G(C, V)​$ and a variable assignment $v​$, $g(v)​$ is a Boolean value describing whether $g​$ is satisfied by $v​$ or not.

##### Control Vector and Configuration

A *control vector* $\bar{l}$ of a network $\bar{A}$ is a vector of locations where $l_i$ is a location of $A_i$. We shall write $\bar{l}[l_i' / l_i ]$ to denote the vector where the $i$th element $l_i$ of $\bar{l}$ is replaced by $l_i'$.

A *state* of a network $\bar{A}$ is a configuration $\lang \bar{l}, v \rang$ where $\bar{l}$ is a control vector of $\bar{A}$ and $v$ is a variable assignment. The initial state of $\bar{A}$ is a $\lang \bar{l_0}, v_0 \rang$ where $\bar{l_0}$ is the initial control vector whose elements are the initial locations of $A_i$'s and $v_0$ is the initial variable assignment that maps all variables to $0$.

##### Transition Rules

The semantics of a network of automata $\bar{A}$ is given in terms of a transition system with the set of states being the set of configurations and the transition relation defined as follows:

**Definition 2** (*Transition Rules for Networks of Automata with Committed Locations*)

* $\lang \bar{l}, v \rang \rightsquigarrow \lang \bar{l} [\bar{l_i'/l_i}, r_i(v) \rang​$ if for some $i​$
  1. $l_i \xrightarrow{g_i, \tau, r_i} l_i'$ (i.e. there is a possible internal transition);
  2. $g_i(v)​$ (the transition is enabled) and
  3. $C(l_k) \implies k = i​$ (no other component except $l_i​$ is committed)
* $\lang \bar{l}, v \rang \rightsquigarrow \lang \bar{l}[l_i'/l_i, l_j'/l_j], (r_i \cup r_j)(v) \rang​$ if for some $i​$, $j​$:
  1. $l_i \xrightarrow{g_i, \alpha!, r_i} l_i'$ and $l_i \xrightarrow{g_j, \alpha?, r_j} l_j'$ for some $\alpha$ (there is a synchronization by two possible transitions);
  2. $g_i(v)​$ and $g_j(v)​$ (the two transitions are enabled) and
  3. $C(l_k) \implies (k = i) \lor (k = j)​$ (no other components except $l_i​$ and $l_j​$ are committed)
* $\lang \bar{l}, v \rang \rightsquigarrow \lang \bar{l}, v \oplus d \rang$ if
  1. there is no $i, j, \alpha \in U$ such that $l_i \xrightarrow{g_i, \alpha!, r_i} l_i'$ and $l_j \xrightarrow{g_j, \alpha?, r_j} l_j'$ (there is no urgent synchronization);
  2. there is no $i$ such that $C(l_i)$ ($\bar{l}$ is not a committed location) and
  3. for all $i$: $I(l_i)(v + d)$ ( the delay is allowed by the invariant conditions).

(*Third one is for passage of time*)

### The Uppaal Model-Checker

In the current version, Uppaal is able to check for reachability properties, in particular whether certain combinations of control-nodes and constraints on clock and data variables are reachable from an initial configuration.

#### Logic

The properties that can be analyzed are of the form:
$$
\phi ::= \forall \square \beta \vert \exist \diamond \beta
$$

$$
\beta ::= a \vert \beta_1 \land \beta_2 \vert \neg{\beta}
$$

Where $a$ is an atomic formula being either an atomic clock (or data) constraint ($c$) or a component location ($A_i \text{ at } l$). Atomic clock (data) constraints are either integer bounds on individual clock (data) variables (e.g. $1 \le x \le 5$) or integer bounds on differences of two clock (data) variables (e.g. $3 \le x - y \le 7$).

Intuitively, for $\forall \square \beta$ to be satisfied, all reachable states must satisfy $\beta$. Dually, for $\exist\diamond\beta$ to be satisfied, some reachable state must satisfy $\beta$. Formally, let $\rightsquigarrow^*$ denote the [transitive closure](https://en.wikipedia.org/wiki/Transitive_closure) of the delay- and action-transition relations between network configurations. Then the satisfaction relation $\models$ between network configurations and formulas are defined as follows:
$$
\lang \bar{l}, v \rang \models \exist \diamond \beta \iff \exist \lang \bar{l}', v' \rang : (\lang \bar{l}, v \rang \rightsquigarrow^* \lang \bar{l}', v' \rang) \land (\lang \bar{l}', v' \rang \models \beta)
$$

$$
\lang \bar{l}, v \rang \models \forall \square \beta \iff \forall \lang \bar{l}', v' \rang : (\lang \bar{l}, v \rang \rightsquigarrow^* \lang \bar{l}', v' \rang) \implies (\lang \bar{l}', v' \rang \models \beta)
$$

Satisfaction with respect to a Boolean combination $\beta$ of atomic formulas is defined inductively on the structure of $\beta$ (behaving as usual with respect to the Boolean connectives). Satisfaction with respect to an atomic formula is given by the following definitions:
$$
\lang \bar{l}, v \rang \models c \iff v \in c
$$

$$
\lang \bar{l}, v \rang \models A_i \text{ at } l \iff l_i = l
$$

#### Test Automata

Our (simple and efficient) model-checking technique extends to the logic presented in [Diagnostic Model-Checking for Real-Time Systems (575-586)](https://link.springer.com/chapter/10.1007/BFb0020977) ([secondary link](https://www.it.uu.se/research/group/darts/papers/texts/dimacs95.pdf)), which also allows for bounded liveness properties to be specified. Currently, bounded liveness properties must be obtained by reachability analysis of the system in the context of testing (and time-sensitive) automata.

Consider the following real-time property $\psi$:
$$
\psi = \phi \text{ Until }_{\lt t} a
$$
stating that the (atomic) property $a$ must hold before $t$ time units and that $\phi$ must hold *until* then. Here we assume that $a$ is of the form $A_i \text{ at } l$. Now to verify that a system S satisfies $\psi$ we extend it with the test automata $T$:

![1551035819902](images\Figure5.png)

Here $T'$ is assumed to be an already constructed test automata for the sub-property $\phi$ (*not explained here - does it circle back into the predecessor location?*), and $'a'$ is a probe action inserting into the component $A_i$ at location $l$. Now, it can be shown that our original system $S$ will satisfy $\phi \text{ Until }_{\lt t} a$ if and only if $S \vert T$ satisfies the invariance property $\forall \square \neg (T \text { at } \text{bad})$.

We conjecture that all bounded liveness properties of the logic in DMfRTS can be translated into reachability problems in this manner, and in a forthcoming version of Uppaal we intend to provide automatic support for generation of test automata from logical formulas (as has been done in the tool SPIN, where 'never-claims' are directly generated form Linear Temporal Logic properties).

#### Model Checking

The model-checking procedure implemented in Uppaal is based on an interpretation using a finite-state symbolic semantics of networks. More precisely, we intepret the logic with respect to symbolic network configurations of the form $[\bar{l}, D]$, where $D$ is a constraint system (i.e. a conjunction of atomic clock and data constraints) and $\bar{l}$ a control-vector. Some of the rules defining this symbolic interpretation is given in the table below:
$$
\dfrac{D \sube c}{\vdash [\bar{l}, D] : c}
\quad
\dfrac{l_i = l}{\vdash [\bar{l}, D] : A_i \text{ at } l}
\quad
\dfrac{\vdash [\bar{l}, D] : \beta}{\vdash [\bar{l}, D] : \exist \diamond \beta} 
$$

$$
\dfrac
{\vdash
[\bar{l}[m_i/l_i, m_j/l_j], (r_i \cup r_j)(D \land g_i \land g_j)] : \exist \diamond \beta
}
{\vdash
[\bar{l}, D] : \exist \diamond \beta
}
\left[\begin{array}{c}
l_i \xrightarrow{g_i, \alpha?, r_i} m_i \\
l_j \xrightarrow{g_j, \alpha!, r_j} m_j
\end{array}\right]
$$

$$
\dfrac
{\vdash [\bar{l}, D^\uparrow] : \exist \diamond \beta}
{\vdash [\bar{l}, D] : \exist \diamond \beta}
$$

To read the rules of the table above some notation needs to be explained. For $D$, a constraint system, and $r$, a set of variables (to be reset), $r(D)$ denotes the set of variable assignments $\{r(v) \vert v \in D\}$. Now $D^\uparrow$ denotes the following set of variable assignments:
$$
D^\uparrow = \{v \oplus d \vert \exist v \in D \exist d \in R : I(\bar{l})(v \oplus d) \}
$$
An important observation is that, whenever D is a constraint system (i.e. a conjunction of atomic clock and data constraints), then so are both $r(D)$ and $D^\uparrow$ (*what?*). Moreover, due to Richard Bellman representing constraint systems as weighted directed graphs (with clock and data variables as nodes), these operations, as well as testing for inclusion between constraint systems may be effectively implemented in $O(n^2)$ and $O(n^3)​$ using some shortest path algorithms.

Now, by applying the proof rules of the table in a goal directed manner we obtain an algorithm for deciding whether a given symbolic network configuration $[\bar{l}, D]$ satisfies a property $\exist \diamond \beta$. To ensure termination (and efficiency), we maintain a past list $L$ of the symbolic network configurations encountered. If, during the goal directed application of the proof rules of Table 1, a symbolic network configuration is generated which is already "covered" by a configuration, then the goal directed search fails at that configuration and backtracking is needed. If an encountered configuration "covers" some configuration already encountered, then the new configuration will replace the covered configuration in $L$.

### The Uppaal Simulator

The simulator allows the user to examine in an interactive and graphical fashion the dynamic behavior of a system. This will in early stages of a design provide an inexpensive means of fault detection. In comparison the model-checker is obviously more expensive as it amounts to an exhaustive simulation covering all behavior of the system.

The simulator and the model-checker share the same semantic basis.

#### Architecture

The bottom layer of the architecture - Network of Automata - is the data-structure representing networks of automata.

This layer contains both the structural properties and the graphical representation of automata. It only has the functionality necessary to let it load files and initialize data structures. This layer only represents structure and it is not responsible for implementing any semantics of the automata.

On top of the layer modeling automata is the Symbolic Single Stepper. This layer handles the semantics of networks of automata. It is capable of simulating automata one step at a time. Basically, the layer presents the possible steps from the current state. It is possible to pick one of these steps and the layer will then calculate the new current state and present the new possibilities. It is possible to pick one of these steps and the layer will then calculate the new current state and present the new possibilities. At any point in time it is furthermore possible to extract the current trace (trace leading from the initial state to the current state). A trace is an alternating sequence of the states visited, and the transitions taken between them.

However, the simulation performed in the symbolic single stepper is not an ordinary simulation. Rather it is time abstracted. By time abstracted we mean that the choice of exact delay in different locations is not performed during the simulation. Instead the simulator is symbolically keeping track of all the delays that could be performed in all the locations in the current trace. With this knowledge it is possible to extract any ordinary trace with exact delays.

The top layer of the system is the GUI.

#### The Symbolic Single Stepper Explained

*Omitted for brevity.*

