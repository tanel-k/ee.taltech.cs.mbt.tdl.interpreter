systemPickle(ctx) ::= <<
package <ctx.package>;

import ee.taltech.cs.mbt.tdl.commons.utils.collections.CollectionUtils;

<ctx.imports:{importPath|import <importPath>}; separator=";\n">

public class <ctx.name;format="cap">SystemFactory {
<if(ctx.systemDefinition)>
    <systemDefinitionFactory(ctx.systemDefinition)>
<endif>

    <ctx.templates:templateFactory(); separator="\n\n">

    protected <ctx.name;format="cap">SystemFactory() { }

    public static <ctx.name;format="cap">SystemFactory new<ctx.name;format="cap">SystemFactory() {
        return new <ctx.name;format="cap">SystemFactory();
    }

    public <ctx.name;format="cap">SystemFactory() { }

    <ctx.declarations:declarationConstructor(); separator="\n">

    <ctx.templates:templateConstructor(); separator="\n">

    <systemDefinitionConstructor(ctx.systemDefinition)>

    public UtaSystem new<ctx.name;format="cap">System() {
        UtaSystem <ctx.name> = new UtaSystem();

        // Set global declarations:
        <ctx.declarations:{declCtx|<declarationConsumer(ctx.name, declCtx)>}; separator="\n">

        // Set templates:
        <ctx.templates:{templateCtx|<templateConsumer(ctx.name, templateCtx)>}; separator="\n">
<if(ctx.systemDefinition)>
        // Set system definition:
        <systemDefinitionConsumer("system", ctx.name)>
<endif>
        return <ctx.name>;
    }
}
>>

templateFactory(ctx) ::= <<
public static class <ctx.name;format="cap">TemplateFactory {
    public static <ctx.name;format="cap">TemplateFactory new<ctx.name;format="cap">TemplateFactory() {
        return new <ctx.name;format="cap">TemplateFactory();
    }

    protected <ctx.name;format="cap">TemplateFactory() { }

    <ctx.parameters:parameterDeclarationConstructor(); separator="\n">

    <ctx.declarations:declarationConstructor(); separator="\n">

    <ctx.locations:locationConstructor(); separator="\n">

    <ctx.transitions:transitionConstructor(); separator="\n">

    public Template new<ctx.name;format="cap">Template() {
        Template <ctx.name> = new Template();

        // Template name:
        Identifier identifier = Identifier.of("<ctx.name>");
        <ctx.name>.setIdentifier(identifier);

        // Set parameter declarations:
        <ctx.parameters:{paramCtx|<parameterDeclarationConsumer(ctx.name, paramCtx)>}; separator="\n">

        // Set local declarations:
        <ctx.declarations:{declCtx|<declarationConsumer(ctx.name, declCtx)>}; separator="\n">

        // Set locations:
        <ctx.locations:{locCtx|<locationConsumer(ctx.name, locCtx)>}; separator="\n">

        // Set transitions:
        <ctx.transitions:{trCtx|<transitionConsumer(ctx.name, trCtx)>}; separator="\n">

        return <ctx.name>;
    }
}
>>

parameterDeclarationConstructor(ctx) ::= <<
protected ParameterDeclaration new<ctx.name; format="cap">ParameterDeclaration() {
    return <newParameter(ctx)>;
}
>>

parameterDeclarationConsumer(targetVar, ctx) ::= <<
CollectionUtils.addIfNonNull(
    <targetVar>.getParameters(),
    new<ctx.name;format="cap">ParameterDeclaration()
);
>>

templateConstructor(ctx) ::= <<
protected Template new<ctx.name;format="cap">Template() {
    return <ctx.name;format="cap">TemplateFactory
        .new<ctx.name;format="cap">TemplateFactory()
        .new<ctx.name;format="cap">Template();
}
>>

templateConsumer(targetVar, ctx) ::= <<
CollectionUtils.addIfNonNull(
    <targetVar>.getTemplates(),
    new<ctx.name;format="cap">Template()
);
>>

locationConstructor(ctx) ::= <<
protected Location new<ctx.id;format="cap">Location() {
    return <newLocation(ctx)>;
}
>>

locationConsumer(tarvetVar, ctx) ::= <<
Location location<ctx.id;format="cap"> = new<ctx.id;format="cap">Location();
template<targetVar;format="cap">.getLocationGraph()
    .addVertex(location<ctx.id;format="cap">);
<if(ctx.initial)>template<targetVar;format="cap">.setInitialLocation(location<ctx.id;format="cap">);<endif>
>>

transitionConstructor(ctx) ::= <<
protected Transition new<ctx.uniqueId;format="cap">Transition(Location source, Location target) {
    return <newTransition(ctx)>;
}
>>

transitionConsumer(targetVar, ctx) ::= <<
Transition transition<ctx.uniqueId;format="cap"> = new<ctx.uniqueId;format="cap">Transition(
    location<ctx.sourceId;format="cap">,
    location<ctx.targetId;format="cap">
);
targetVar.getLocationGraph()
    .addEdge(location<ctx.sourceId;format="cap">, location<ctx.targetId;format="cap">);
>>

declarationConstructor(ctx) ::= <<
protected AbsDeclarationStatement new<ctx.name>Declaration() {
    return <newDeclaration(ctx)>;
}
>>

declarationConsumer(targetVar, ctx) ::= <<
CollectionUtils.addIfNonNull(
    <targetVar>.getDeclarations(),
    new<ctx.name; format="cap">Declaration()
);
>>

systemDefinitionConstructor(ctx) ::= <<
protected SystemDefinition newSystemDefinition() {
    return <newSystemDefinition(ctx)>;
}
>>

systemDefinitionConsumer(targetVar) ::= <<
SystemDefinition systemDefinition = newSystemDefinition();
<targetVar>.setSystemDefinition(systemDefinition);
>>

newSystemDefinition(ctx) ::= <<
new SystemDefinition()
    <ctx.declarations:{declCtx|
    .addDeclaration(<newDeclaration(declCtx)>)}>
<if(ctx.systemLine)>
    .setSystemLine(
        new SystemLine()
        <ctx.systemLine.processReferenceGroups:{grpCtx|
            .addGroup(
                new ProcessReferenceGroup()
                    <grpCtx.identifiers:{idCtx|
                    .addIdentifier(Identifier.of("<idCtx>"))}>
            )}>
    )
<endif>
    <ctx.progressMeasures:{exprCtx|
    .addProgressMeasure(<newExpression(exprCtx)>)}>
>>

newLocation(ctx) ::= <<
new Location()
    .setId("<ctx.id>")
<if(ctx.name)>
    .setName("<ctx.name>")
<endif>
    .setLabels(
        new LocationLabels()
<if(ctx.labels.invariant)>
            .setInvariant(<newInvariantLabel(ctx.labels.invariant)>)<endif>
<if(ctx.labels.comment)>
            .setCommentLabel(<newCommentLabel(ctx.labels.comment)>)
<endif>
    )
<if(ctx.colorValue)>
    .setColor(Color.of(<ctx.colorValue>))
<endif>
    .setCoordinates(GuiCoordinates.of(<ctx.coordinates.x>, <ctx.coordinates.y>))
>>

newTransition(ctx) ::= <<
new Transition()
    .setSource(source)
    .setTarget(target)
<if(ctx.colorValue)>
    .setColor(Color.of(<ctx.colorValue>))
<endif>
    .setLabels(
        new TransitionLabels()
<if(ctx.labels.guard)>
            .setGuardLabel(<newGuardLabel(ctx.labels.guard)>)
<endif>
<if(ctx.labels.comment)>
            .setCommentLabel(<newCommentLabel(ctx.labels.comment)>)
<endif>
<if(ctx.labels.assignments)>
            .setAssignmentsLabel(<newAssignmentsLabel(ctx.labels.assignments)>)
<endif>
<if(ctx.labels.selection)>
            .setSelectLabel(<newSelectionLabel(ctx.labels.selection)>)
<endif>
<if(ctx.labels.synchronization)>
            .setSynchronizationLabel(<newSynchronizationLabel(ctx.labels.synchronization)>)
<endif>
    )
    <ctx.nails:{nailCtx|{
    .addNail(GuiCoordinates.of(nailCtx.x, nailCtx.y))}>
>>

newCommentLabel(ctx) ::= <<
new CommentLabel().setContent("<ctx.commentText>")
>>

newInvariantLabel(ctx) ::= <<
new InvariantLabel().setContent(
    <newExpression(ctx.expression)>
)
>>

newGuardLabel(ctx) ::= <<
new GuardLabel().setContent(
    <newExpression(ctx.expression)>
)
>>

newAssignmentsLabel(ctx) ::= <<
new AssignmentsLabel().setContent(
    CollectionUtils.collectionBuilder(new LinkedList\<AbsExpression\>())
        <ctx.expressions:{exprCtx|
        .add(
            <newExpression(exprCtx)>)
        }>
        .build()
)
>>

newSelectionLabel(ctx) ::= <<
new SelectionLabel().setContent(
    CollectionUtils.collectionBuilder(new LinkedList\<Selection\>())
        <ctx.expressions:{selCtx|
        .add(
            <newSelection(selCtx)>
        )}>
        .build()
)
>>

newSelection(ctx) ::= <<
new Selection()
    .setVariableName(Identifier.of("<ctx.variableName>"))
    .setSelectType(<newBaseType(ctx.selectType)>)
>>

newSynchronizationLabel(ctx) ::= <<
new SynchronizationLabel().setContent(
    new Synchronization()
        .setActiveSync(<if(ctx.synchronization.active)>true<else>false<endif>)
        .setExpression(<newExpression(ctx.synchronization.expression)>)
)
>>

newParameter(ctx) ::= <<
new ParameterDeclaration()
    .setIdentifier(Identifier.of("<ctx.identifier>"))
    .setType(<newType(ctx.type)>)
>>

newDeclaration(ctx) ::= <%
    <if(ctx.variableDeclaration)>
        <newVariableDeclaration(ctx)>
    <elseif(ctx.typeDeclaration)>
        <newTypeDeclaration(ctx)>
    <elseif(ctx.channelPriorityDeclaration)>
        <newChannelPriorityDeclaration(ctx)>
    <elseif(ctx.templateInstantiation)>
        <newTemplateInstantiation(ctx)>
    <elseif(ctx.functionDeclaration)>
        <newFunctionDeclaration(ctx)>
    <endif>
%>

newChannelPriorityDeclaration(ctx) ::= <<
new ChannelPrioritySequence()
    <ctx.channelReferenceGroups:{grpCtx |
        .addGroup(
            new ChannelReferenceGroup()
                <grpCtx.channelReferences:{refCtx|
                .addReference(<newChannelReference(refCtx)>)}>
        )}>
>>

newChannelReference(ctx) ::= <<
<if(ctx.defaultPriority)>
DefaultChannelReference.INSTANCE
<elseif(ctx.channelIdentifier)>
new ChannelIdentifierReference()
    .setIdentifier(Identifier.of("<ctx.identifier>"))
<elseif(ctx.arrayLookup)>
new ChannelArrayLookup().setArrayVariableLookup(
    new ArrayVariableLookup()
        .setIdentifier(Identifier.of("<ctx.arrayName>"))
        <ctx.lookupExpressions:{exprCtx|
        .addLookupExpression(<newExpression(exprCtx)>)}>
)
<endif>
>>

newTemplateInstantiation(ctx) ::= <<
new TemplateInstantiation()
    .setNewTemplateName(Identifier.of("<ctx.newTemplateName>"))
    .setSourceTemplateName(Identifier.of("<ctx.sourceTemplateName>"))
    <ctx.parameters:{paramCtx|
    .addParameter(
        new ParameterDeclaration()
            .setIdentifier(Identifier.of("<paramCtx.identifier>"))
            .setType(<newType(paramCtx.type)>)
    )}>
    <ctx.arguments:{argCtx|
    .addArgument(
        <newExpression(argCtx)>
    )}>
>>

newFunctionDeclaration(ctx) ::= <<
new FunctionDeclaration()
<if(ctx.valueType)>
    .setValueType(<newBaseType(ctx.valueType)>)
<endif>
    .setName(Identifier.of("<ctx.name>"))
    <ctx.parameters:{paramCtx|
    .addParameter(
        new ParameterDeclaration()
            .setIdentifier(Identifier.of("<paramCtx.identifier>"))
            .setType(<newType(paramCtx.type)>)
    )
    }>
    .setStatementBlock(<newStatement(ctx.statementBlock)>)
>>

newVariableDeclaration(ctx) ::= <%
    <if(ctx.singleVariableDeclaration)>
        <newSingleVariableDeclaration(ctx)>
    <elseif(ctx.multiVariableDeclaration)>
        <newMultiVariableDeclaration(ctx)>
    <endif>
%>

newTypeDeclaration(ctx) ::= <%
    <if(ctx.singleTypeDeclaration)>
        <singleTypeDeclaration(ctx)>
    <elseif(ctx.multiDeclaration)>
        <multiTypeDeclaration(ctx)>
    <endif>
%>

newSingleVariableDeclaration(ctx) ::= <<
new VariableDeclaration()
    .setType(<newType(ctx.type)>)
    .setIdentifier(Identifier.of("<ctx.identifier>"))
<if(ctx.initializer)>
    .setInitializer(<newInitializer(ctx.initializer)>)
<endif>
>>

newMultiVariableDeclaration(ctx) ::= <<
new VariableDeclarationGroup()
    .setBaseType(<newBaseType(ctx.baseType)>)
    <ctx.subDeclarations:{declCtx|
    .
    }>
    <baseType(ctx.baseType)> <ctx.subDeclarations:subVariableDeclaration(); separator=", ">;
>>
// UNDER CONSTRUCTION:
newInitializer(ctx) ::= <<
// TODO
>>



subVariableDeclaration(ctx) ::= <%
    <ctx.identifierValue><arrayModifiers(ctx.arrayModifiers)>
    <if(ctx.initializer)> = <variableInitializer(ctx.initializer)><endif>
%>

variableInitializer(ctx) ::= <%<if(ctx.structuredInitializer)>{
    <ctx.nestedInitializers:variableInitializer(); separator=",\n">
}<elseif(ctx.flatInitializer)><expression(ctx.expression)><endif>
%>

singleTypeDeclaration(ctx) ::= <%
    typedef <baseType(ctx.type.baseType)> <ctx.identifierValue><arrayModifiers(ctx.type.arrayModifiers)>;
%>

multiTypeDeclaration(ctx) ::= <%
    typedef <baseType(ctx.baseType)> <ctx.subDeclarations:subTypeDeclaration(); separator=", ">;
%>

subTypeDeclaration(ctx) ::= <%
    <ctx.identifierValue><arrayModifiers(ctx.arrayModifiers)>
%>

// BEGIN: Statements
newStatement(ctx) ::= <%
    <if(ctx.blockStatement)>
        <newBlockStmt(ctx)>
    <elseif(ctx.forLoopStatement)>
        <newForStmt(ctx)>
    <elseif(ctx.iterationStatement)>
        <newIterationStmt(ctx)>
    <elseif(ctx.whileStatement)>
        <newWhileStmt(ctx)>
    <elseif(ctx.doWhileStatement)>
        <newDoWhileStmt(ctx)>
    <elseif(ctx.conditionalStatement)>
        <newConditionalStmt(ctx)>
    <elseif(ctx.expressionStatement)>
        <newExpression(ctx.expression)>;
    <elseif(ctx.returnStatement)>
        new ReturnStatement()<if(ctx.expression)>.setExpression(<newExpression(ctx.expression)>)<endif>
    <elseif(ctx.emptyStatement)>
        EmptyStatement.getInstance()
    <endif>
%>

newBlockStmt(ctx) ::= <<{
<if(ctx.declarations)>
    <declarations(ctx.declarations)>
<endif>
<if(ctx.statements)>
    <ctx.statements:statement(); separator="\n">
<endif>
}>>

newForStmt(ctx) ::= <<for (<expression(ctx.initializer)>; <expression(ctx.condition)>; <expression(ctx.update)>)
    <statment(ctx.statement)>
>>

newIterationStmt(ctx) ::= <<for (<ctx.identifierValue> : <type(ctx.iteratedType)>)
    <statement(ctx.statement)>
>>

newWhileStmt(ctx) ::= <<while (<expression(ctx.condition)>)
    <statement(ctx.statement)>
>>

newDoWhileStmt(ctx) ::= <<do
    <statement(ctx.statement)>
while (<expression(ctx.condition)>);
>>

newConditionalStmt(ctx) ::= <<if (<expression(ctx.condition)>)
    <statement(ctx.primary)>
<if(ctx.alternative)>
else
    <statement(ctx.alternative)>
<endif>
>>
// END: Statements

// BEGIN: Expressions
newExpression(ctx) ::= <%
    <if(ctx.group)>
        (<expression(ctx.child)>)
    <elseif(ctx.arrayLookup)>
        <expression(ctx.leftChild)>[<expression(ctx.rightChild)>]
    <elseif(ctx.fieldAccess)>
        <expression(ctx.child)>.<ctx.identifierValue>
    <elseif(ctx.negation)>
        <if(ctx.phrasal)>
            not <expression(ctx.child)>
        <else>
            !<expression(ctx.child)>
        <endif>
    <elseif(ctx.conjunction)>
        <if(ctx.phrasal)>
            <expression(ctx.leftChild)> and <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> && <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.disjunction)>
        <if(ctx.phrasal)>
            <expression(ctx.leftChild)> or <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> || <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.prefixIncrement)>
        ++<expression(ctx.child)>
    <elseif(ctx.postfixIncrement)>
        <expression(ctx.child)>++
    <elseif(ctx.prefixDecrement)>
        --<expression(ctx.child)>
    <elseif(ctx.postfixDecrement)>
        <expression(ctx.child)>--
    <elseif(ctx.additiveInverse)>
        -<expression(ctx.child)>
    <elseif(ctx.additiveIdentity)>
        +<expression(ctx.child)>
    <elseif(ctx.multiplication)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> *= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> * <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.division)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> /= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> / <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.modulo)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> %= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> % <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.subtraction)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> -= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> - <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.addition)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> += <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> + <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.leftShift)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> \<\<= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> \<\< <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.rightShift)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> >>= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> >> <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.maximum)>
        <expression(ctx.leftChild)> >? <expression(ctx.rightChild)>
    <elseif(ctx.minimum)>
        <expression(ctx.leftChild)> \<? <expression(ctx.rightChild)>
    <elseif(ctx.lessThan)>
        <expression(ctx.leftChild)> \< <expression(ctx.rightChild)>
    <elseif(ctx.lessThanOrEqual)>
        <expression(ctx.leftChild)> \<= <expression(ctx.rightChild)>
    <elseif(ctx.greaterThan)>
        <expression(ctx.leftChild)> > <expression(ctx.rightChild)>
    <elseif(ctx.greaterThanOrEqual)>
        <expression(ctx.leftChild)> >= <expression(ctx.rightChild)>
    <elseif(ctx.equality)>
        <expression(ctx.leftChild)> == <expression(ctx.rightChild)>
    <elseif(ctx.inequality)>
        <expression(ctx.leftChild)> != <expression(ctx.rightChild)>
    <elseif(ctx.bitwiseAnd)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> &= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> & <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.bitwiseXor)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> ^= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> ^ <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.bitwiseOr)>
        <if(ctx.assignment)>
            <expression(ctx.leftChild)> |= <expression(ctx.rightChild)>
        <else>
            <expression(ctx.leftChild)> | <expression(ctx.rightChild)>
        <endif>
    <elseif(ctx.ternary)>
        <expression(ctx.leftChild)> ? <expression(ctx.middleChild)> : <expression(ctx.rightChild)>
    <elseif(ctx.existentialQuantification)>
        exists (<ctx.identifierValue> : <type(ctx.type)>) <expression(ctx.child)>
    <elseif(ctx.universalQuantification)>
        forall (<ctx.identifierValue> : <type(ctx.type)>) <expression(ctx.child)>
    <elseif(ctx.assignmentExpression)>
        <expression(ctx.leftChild)> = <expression(ctx.rightChild)>
    <elseif(ctx.call)>
        <expression(ctx.child)>(<arguments(ctx.arguments)>)
    <elseif(ctx.literal)>
        <literal(ctx)>
    <elseif(ctx.identifier)>
        <ctx.identifierValue>
    <endif>
%>

// BEGIN: Expression utils
literal(ctx) ::= <%
    <if(ctx.deadlockLiteral)>
        deadlock
    <elseif(ctx.trueLiteral)>
        true
    <elseif(ctx.falseLiteral)>
        false
    <elseif(ctx.naturalNumberLiteral)>
        <ctx.naturalNumber>
    <endif>
%>
// END: Expression utils
// END: Expressions

// BEGIN: Types
newBaseType(ctx) ::= <%
    <if(ctx.prefix)><typePrefix(ctx.prefix)> <endif><typeId(ctx.typeId)>
%>

typePrefix(ctx) ::= <%
    <if(ctx.urgent)>
        urgent
    <elseif(ctx.broadcast)>
        broadcast
    <elseif(ctx.meta)>
        meta
    <elseif(ctx.constant)>
        const
    <endif>
%>

newTypeId(ctx) ::= <%
    <if(ctx.struct)>
        struct <fieldDeclarations(ctx.fieldDeclarations)>
    <elseif(ctx.scalar)>
        scalar [<expression(ctx.expression)>]
    <elseif(ctx.customType)>
        <ctx.identifierValue>
    <elseif(ctx.boundedInt)>
        int[<expression(ctx.minExpression)>, <expression(ctx.maxExpression)>]
    <elseif(ctx.boolean)>
        bool
    <elseif(ctx.int)>
        int
    <elseif(ctx.chan)>
        chan
    <elseif(ctx.clock)>
        clock
    <endif>
%>

// BEGIN: Type utils
fieldDeclarations(iterable) ::= <<{
    <iterable:fieldDeclaration(); separator="\n">
}
>>

newFieldDeclaration(ctx) ::= <%
    <if(ctx.singleDeclaration)>
        <singleDeclaration(ctx)>
    <elseif(ctx.multiDeclaration)>
        <multiDeclaration(ctx)>
    <endif>
%>

singleDeclaration(ctx) ::= <%
    <baseType(ctx.type.baseType)> <if(ctx.type.referenceType)>&<endif><ctx.name><arrayModifiers(ctx.type.arrayModifiers)>;
%>

multiDeclaration(ctx) ::= <%
    <baseType(ctx.baseType)> <extendedTypes(ctx.extendedTypes)>;
%>
// END: Type utils
// END: Types

// BEGIN: General utils


parameter(ctx) ::= <%
    <baseType(ctx.type.baseType)> <if(ctx.type.referenceType)>&<endif><ctx.name><arrayModifiers(ctx.type.arrayModifiers)>
%>

extendedTypes(iterable) ::= <%
    <iterable:extendedType(); separator=", ">
%>

extendedType(ctx) ::= <%
    <if(ctx.referenceType)>&<endif><ctx.identifierValue><ctx.arraySizeModifiers:arraySizeModifier()>
%>

arrayModifiers(iterable) ::= <%
    <iterable:arrayModifier()>
%>

arrayModifier(ctx) ::= <%
    <if(ctx.sizeFromType)>
        [<baseType(ctx.sizeType)>]
    <elseif(ctx.sizeFromExpression)>
        [<expression(ctx.sizeExpression)>]
    <endif>
%>
// END: General utils
